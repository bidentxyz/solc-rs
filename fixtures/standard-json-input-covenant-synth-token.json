{
    "language": "Solidity",
    "sources": {
        "src/synths/SynthToken.sol": {
            "content": "pragma solidity ^0.8.30;\n\nimport {ISynthToken, IERC20, MarketId, AssetType} from \"../interfaces/ISynthToken.sol\";\nimport {ERC20} from \"@openzeppelin/token/ERC20/ERC20.sol\";\n\n/**\n * @title Synthetic asset\n * @author Covenant Labs\n * @dev ERC20, closely integrated with CovenantCore\n */\ncontract SynthToken is ERC20, ISynthToken {\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Errors\n    error E_Synth_OnlyLEXCoreCanCall();\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    modifier onlyLexCore() {\n        if (_lexCore != _msgSender()) revert E_Synth_OnlyLEXCoreCanCall();\n        _;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Immutables\n\n    address private immutable _covenantCore;\n    address private immutable _lexCore; // autharized lex for mint/burn actions\n    MarketId private immutable _marketId; // marketId associated with synth token\n    AssetType private immutable _synthType; // type of synth token\n    uint8 private immutable _decimals; // asset decimals\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    // Constructor\n    constructor(\n        address covenantCore_,\n        address lexCore_,\n        MarketId marketId_,\n        IERC20 baseAsset_,\n        AssetType synthType_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _covenantCore = covenantCore_;\n        _lexCore = lexCore_;\n        _marketId = marketId_;\n        _synthType = synthType_;\n        _decimals = decimals_;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    // ERC20 Overrides\n\n    function decimals() public view override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    // Public Getters (non ERC20)\n\n    function getCovenantCore() external view override returns (address) {\n        return _covenantCore;\n    }\n\n    function getMarketId() external view override returns (MarketId) {\n        return _marketId;\n    }\n\n    function getSynthType() external view override returns (AssetType) {\n        return _synthType;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    // Covenant Liquid only functions (non ERC20)\n\n    /**\n     * @dev Expose share mint functionality to Covenant Liquid\n     */\n    function lexMint(address account, uint256 value) external onlyLexCore {\n        _mint(account, value);\n    }\n\n    /**\n     * @dev Expose share redeem functionality to Covenant Liquid\n     */\n    function lexBurn(address account, uint256 value) external onlyLexCore {\n        _burn(account, value);\n    }\n}\n"
        },
        "src/interfaces/ISynthToken.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {MarketId, AssetType} from \"../interfaces/ICovenant.sol\";\nimport {IERC20} from \"@openzeppelin/token/ERC20/IERC20.sol\";\n\n/**\n * @title ICovenant\n * @author Amorphous\n * @notice Defines the the core interface of Covenant Liquid markets.\n **/\ninterface ISynthToken is IERC20 {\n    // Notice - gets CovenantCore associated with the SynthToken\n    function getCovenantCore() external returns (address);\n\n    // Notice - gets marketId associated with the SynthToken\n    function getMarketId() external returns (MarketId);\n\n    // Notice - gets synthType associated with the SynthToken\n    function getSynthType() external returns (AssetType);\n\n    /**\n     * @dev Expose share mint functionality to Covenant Liquid\n     */\n    function lexMint(address account, uint256 value) external;\n\n    /**\n     * @dev Expose share redeem functionality to Covenant Liquid\n     */\n    function lexBurn(address account, uint256 value) external;\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
        },
        "src/interfaces/ICovenant.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"./ISynthToken.sol\";\nimport {ILiquidExchangeModel} from \"./ILiquidExchangeModel.sol\";\nimport {Events} from \"../libraries/Events.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\n\ntype MarketId is bytes20;\n\n// Parameters that uniquely defines a Covenant market\nstruct MarketParams {\n    address baseToken;\n    address quoteToken;\n    address curator; // address of the oracle router\n    address lex;\n}\n\nstruct SynthTokens {\n    address aToken;\n    address zToken;\n}\n\nstruct MarketState {\n    uint256 baseSupply; // total base tokens for market\n    uint128 protocolFeeGrowth; // cumulative fee accrued by protocol in base tokens (unclaimed)\n    address authorizedPauseAddress; // address authorized to pause market\n    uint8 statusFlag; // 0 = uninitialized, 1 = unlocked, 2 = locked, 3 = paused\n}\n\nstruct SwapParams {\n    MarketId marketId;\n    MarketParams marketParams;\n    AssetType assetIn;\n    AssetType assetOut;\n    address to;\n    uint256 amountSpecified;\n    uint256 amountLimit;\n    bool isExactIn;\n    bytes data;\n    uint256 msgValue;\n}\n\nstruct RedeemParams {\n    MarketId marketId;\n    MarketParams marketParams;\n    uint256 aTokenAmountIn;\n    uint256 zTokenAmountIn;\n    address to;\n    uint256 minAmountOut;\n    bytes data;\n    uint256 msgValue;\n}\n\nstruct MintParams {\n    MarketId marketId;\n    MarketParams marketParams;\n    uint256 baseAmountIn;\n    address to;\n    uint256 minATokenAmountOut;\n    uint256 minZTokenAmountOut;\n    bytes data;\n    uint256 msgValue;\n}\n\nstruct TokenPrices {\n    uint256 baseTokenPrice;\n    uint256 aTokenPrice;\n    uint256 zTokenPrice;\n}\n\nenum AssetType {\n    BASE, // index 0\n    DEBT, // index 1\n    LEVERAGE, // index 2\n    COUNT // used to get the count of asset types\n}\n\n/**\n * @title ICovenant\n * @author Covenant Labs\n * @notice Defines the the core interface of Covenant Liquid markets.\n **/\ninterface ICovenant {\n    /// @notice Covenant name getter\n    function name() external view returns (string memory);\n\n    /// @notice MarketParams getter\n    function getIdToMarketParams(MarketId marketId) external view returns (MarketParams memory);\n\n    /// @notice MarketState getter\n    function getMarketState(MarketId marketId) external view returns (MarketState memory);\n\n    /// @notice Whether the LEX is enabled.\n    function isLexEnabled(address lex) external view returns (bool);\n\n    /// @notice Whether the Curator (oracle router) is enabled.\n    function isCuratorEnabled(address curator) external view returns (bool);\n\n    /**\n     * @notice creates a new Covenant Liquid market\n     * @param marketParams market initialization parameters\n     **/\n    function createMarket(MarketParams calldata marketParams, bytes calldata initData) external returns (MarketId);\n\n    /**\n     * @notice mints aTokens and zTokens from base tokens.\n     * @param mintParams mint parameters, as detailed below:\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - baseAmountIn: the amount of base token to deposit (and against which to mint a and z tokens)\n     * - to: the receiver of aTokens and zTokens\n     * - minATokenAmountOut: minimum ATokens out\n     * - minZTokenAmountOut: minimum Ztokens out\n     * - data: additional data to send to LEX\n     * - msgValue: msgValue to send to LEX if needed\n     * @return aTokenAmountOut amount of aToken minted\n     * @return zTokenAmountOut amount of zToken minted\n     **/\n    function mint(\n        MintParams calldata mintParams\n    ) external payable returns (uint256 aTokenAmountOut, uint256 zTokenAmountOut);\n\n    /**\n     * @notice Redeems aTokenAmount and zTokenAmount for base token.\n     * @notice Treats amounts as exact input, and does not check for slippage\n     * @dev This function send to LEX msgValue, but does not check whether msg.Value == msgValue (this is done to enable multicalls)\n     * @dev This means that calling with msgValue > msg.Value will revert, and msgValue < msg.Value\n     * @dev will leave excess value in the Covenant contract (which can be used by subsequent function calls or users)\n     * @param redeemParams redeem parameters, as follows:\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - aTokenAmountIn: the aTokenAmount being redeemed / burned (exact in)\n     * - zTokenAmountIn: the zTokenAmount being redeemed / burned (exact in)\n     * - to: the receiver of base tokens\n     * - minAmountOut: the minimum amount of base token out (for slippage / MEV protection)\n     * - data: additional data to send to LEX\n     * - msgValue: msgValue to send to LEX if needed\n     * @return baseAmountOut actual base tokens redeemed\n     **/\n    function redeem(RedeemParams calldata redeemParams) external payable returns (uint256 baseAmountOut);\n\n    /**\n     * @notice Executes a swap between any of the base, aToken, or zToken assets\n     * @dev All parameters are given in raw token decimal encoding.\n     * @dev function returns error if assets being swapped are not part of the same market\n     * @dev swapping between aTokens / zTokens actually mints / burns tokens\n     * @dev This function send to LEX msgValue, but does not check whether msg.Value == msgValue (this is done to enable multicalls)\n     * @dev This means that calling with msgValue > msg.Value will revert, and msgValue < msg.Value\n     * @dev will leave excess value in the Covenant contract (which can be used by subsequent function calls or users)\n     * @param swapParams swap parameters\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - assetIn: AssetType in\n     * - assetOut: AssetType out\n     * - to: the receiver of base tokens\n     * - amountSpecified: swap amount specified (amount in, if isExactIn == true)\n     * - amountLimit: swap reverts if less than amountLimit is return (if isExactIn), or more than amountLimit is expected as input (if !isExactIn)\n     * - isExactIn: whether swap is exact in, or exact out\n     * - data: additional data to send to LEX\n     * - msgValue: msgValue to send to LEX if needed\n     * @return amount amount of tokens swapped out / in, depending on whether swap isExactIn\n     **/\n    function swap(SwapParams calldata swapParams) external payable returns (uint256 amount);\n\n    /**\n     * @notice Updates market state (e.g., accrues debt fees and protocol fees)\n     * @dev Calling mint / redeem / swap also updates internal states, but updateState allows a user to update the state without mint / redeem /swapping tokens\n     * @dev This function send to LEX msgValue, but does not check whether msg.Value == msgValue (this is done to enable multicalls)\n     * @dev This means that calling with msgValue > msg.Value will revert, and msgValue < msg.Value\n     * @dev will leave excess value in the Covenant contract (which can be used by subsequent function calls or users)\n     * @param marketId market to update\n     * @param marketParams marketParams of market to update\n     * @param data additional data to send to LEX\n     * @param msgValue msgValue to send to LEX if needed\n     **/\n    function updateState(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        bytes calldata data,\n        uint256 msgValue\n    ) external payable;\n\n    /**\n     * @notice previews mint of aTokens and zTokens from base tokens, without changing market state\n     * @notice Treats amounts as exact input, runs validation logic as actual mint call\n     * @param mintParams mint parameters, as detailed below:\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - baseAmountIn: the amount of base token to deposit (and against which to mint a and z tokens)\n     * - to: the receiver of aTokens and zTokens\n     * - minATokenAmountOut: minimum ATokens out\n     * - minZTokenAmountOut: minimum Ztokens out\n     * @return aTokenAmountOut amount of aToken minted\n     * @return zTokenAmountOut amount of zToken minted\n     * @return protocolFees amount of fee charged by protocol in base tokens\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices returns the dex prices after the action\n     **/\n    function previewMint(\n        MintParams calldata mintParams\n    )\n        external\n        view\n        returns (\n            uint256 aTokenAmountOut,\n            uint256 zTokenAmountOut,\n            uint128 protocolFees,\n            uint128 oracleUpdateFee,\n            TokenPrices memory tokenPrices\n        );\n\n    /**\n     * @notice previews redeem of aTokenAmount and zTokenAmount for base token, without changing market state.\n     * @notice Treats amounts as exact input, runs validation logic as actual redeem call\n     * @param redeemParams redeem parameters, as follows:\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - aTokenAmountIn: the aTokenAmount being redeemed / burned (exact in)\n     * - zTokenAmountIn: the zTokenAmount being redeemed / burned (exact in)\n     * - to: the receiver of base tokens\n     * - minAmountOut: the minimum amount of base token out (for slippage / MEV protection)\n     * @return amountOut actual base tokens redeemed\n     * @return protocolFees amount of fee charged by protocol in base tokens\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices returns the dex prices after the action\n     **/\n    function previewRedeem(\n        RedeemParams calldata redeemParams\n    )\n        external\n        view\n        returns (uint256 amountOut, uint128 protocolFees, uint128 oracleUpdateFee, TokenPrices memory tokenPrices);\n\n    /**\n     * @notice Calculates output of a swap between any of the base, aToken, or zToken assets, without changing market\n     * @notice Runs validation logic as actual swap call\n     * @param swapParams swap parameters\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - assetIn: AssetType in\n     * - assetOut: AssetType out\n     * - to: the receiver of base tokens\n     * - amountSpecified: swap amount specified (amount in, if isExactIn == true)\n     * - amountLimit: swap reverts if less than amountLimit is return (if isExactIn), or more than amountLimit is expected as input (if !isExactIn)\n     * - isExactIn: whether swap is exact in, or exact out\n     * @return amountCalc amount of tokens swapped out / in, depending on whether swap is EXACT_IN / EXACT_OUT\n     * @return protocolFees amount of fee charged by protocol in base tokens\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices returns the dex prices after the action\n     **/\n    function previewSwap(\n        SwapParams calldata swapParams\n    )\n        external\n        view\n        returns (uint256 amountCalc, uint128 protocolFees, uint128 oracleUpdateFee, TokenPrices memory tokenPrices);\n\n    /**\n     * @notice Payable multicall\n     * @notice Does not check msg.value received.  Instead, it uses any msgValues encoded in data and sends those onwards\n     * @notice This means that calling multicall where sum(data(msgValues)) > msg.Value will revert, and\n     * @notice sum(data(msgValues)) < msg.Value will leave excess value in the Covenant contract (which can be used by subsequent users)\n     * @param data array of call data\n     * @return results an array of return info\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /////////////////////////////////////////////////////////////////////////////////\n    // Restricted functions\n\n    /// @notice Set valid LEX contracts (onlyOwner)\n    /// @notice Disabling a LEX does not allow new markets with this LEX\n    /// but does not invalidate already created markets\n    function setEnabledLEX(address lex, bool isValid) external;\n\n    /// @notice Set valid Curator (oracle router) contracts (onlyOwner)\n    /// @notice Disabling a Curator does not allow new markets with this Curator\n    /// but does not invalidate already created markets\n    function setEnabledCurator(address curator, bool isValid) external;\n\n    /// @notice Set default protocol fee (onlyOwner)\n    function setDefaultFee(uint32 newFee) external;\n\n    /// @notice Set protocol fee for a market (onlyOwner)\n    function setMarketProtocolFee(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        bytes calldata data,\n        uint256 msgValue,\n        uint32 newFee\n    ) external payable;\n\n    /// @notice Collect protocol fees for a market (onlyOwner)\n    function collectProtocolFee(MarketId marketId, address recipient, uint128 amountRequested) external;\n\n    /// @notice Pause a market (only authorized pause address)\n    function setMarketPause(MarketId marketId, bool isPaused) external;\n\n    /// @notice Set default pause address (onlyOwner)\n    function setDefaultPauseAddress(address newPauseAddress) external;\n\n    /// @notice Set pause address for a market (onlyOwner)\n    function setMarketPauseAddress(MarketId marketId, address newPauseAddress) external;\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
        },
        "src/interfaces/ILiquidExchangeModel.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {AssetType, MintParams, RedeemParams, SwapParams, MarketId, MarketParams, TokenPrices, SynthTokens} from \"./ICovenant.sol\";\n\n/**\n * @title ILiquidExchangeModel\n * @author Covenant Labs\n * @notice Defines the the core interface of Liquid Exchange Models\n **/\ninterface ILiquidExchangeModel {\n    ///////////////////////////////////////////////////////////////////////////////\n    // Getters\n\n    /// @notice ProtocolFee getter\n    function getProtocolFee(MarketId marketId) external view returns (uint32);\n\n    /// @notice SynthTokens getter\n    function getSynthTokens(MarketId marketId) external view returns (SynthTokens memory);\n\n    /// @notice LEX name getter\n    function name() external view returns (string memory);\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Write functions (only Covenant calls)\n\n    /// @notice sets protocol Fee for a given market\n    function setMarketProtocolFee(MarketId marketId, uint32 newFee) external;\n\n    /// @notice initializes LEX variables for a market\n    function initMarket(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        uint32 protocolFee,\n        bytes memory initData\n    ) external returns (SynthTokens memory, bytes memory);\n\n    /**\n     * @notice calculate Synth tokens to mint given baseLiquidityIn, and updates internal states.\n     * @notice does not include fees\n     * @param mintParams covenant mint parameters\n     * @param baseTokenSupply total baseToken supply in the market\n     * @param sender sender of tokens coming in\n     * @return aTokenAmountOut amount of aToken to be minted given amountIn\n     * @return zTokenAmountOut amount of zToken to be minted given amountIn\n     * @return protocolFees calculated protocol fees to be charged\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after mint\n     **/\n    function mint(\n        MintParams calldata mintParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        payable\n        returns (\n            uint256 aTokenAmountOut,\n            uint256 zTokenAmountOut,\n            uint128 protocolFees,\n            TokenPrices memory tokenPrices\n        );\n\n    /**\n     * @notice calculates base liquidity out, given synth tokens redeemed, and updates internal states\n     * @notice does not include fees\n     * @notice Treats amounts as exact input, and does not check for slippage\n     * @param redeemParams covenant redeem parameters\n     * @param sender sender of tokens coming in\n     * @param baseTokenSupply total baseToken supply in the market\n     * @return amountOut amount of base token being redeemed\n     * @return protocolFees calculated protocol fees to be charged\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after redeem\n     **/\n    function redeem(\n        RedeemParams calldata redeemParams,\n        address sender,\n        uint256 baseTokenSupply\n    ) external payable returns (uint256 amountOut, uint128 protocolFees, TokenPrices memory tokenPrices);\n\n    /**\n     * @notice calculates swap between tokens (base or synths), and updates internal states\n     * @notice does not include fees\n     * @dev All parameters are given in raw token decimal encoding.\n     * @param swapParams covenant swap parameters\n     * @param sender sender of tokens coming in\n     * @param baseTokenSupply total baseToken supply in the market\n     * @return amountCalculated amount of liquidity swapped out / in, depending on whether swap is EXACT_IN / EXACT_OUT\n     * @return protocolFees calculated protocol fees to be charged\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after swap\n     **/\n    function swap(\n        SwapParams calldata swapParams,\n        address sender,\n        uint256 baseTokenSupply\n    ) external payable returns (uint256 amountCalculated, uint128 protocolFees, TokenPrices memory tokenPrices);\n\n    /**\n     * @notice Updates market state (e.g., accrues debt fees and protocol fees)\n     * @dev Calling mint / redeem / swap also updates internal states, but updateState allows a user to update the state without mint / redeem /swapping tokens\n     * @param marketId market to update\n     * @param marketParams marketParams of market to update\n     * @param baseTokenSupply total baseToken supply in the market\n     * @param data additional data to send to LEX\n     * @return protocolFees calculated protocol fees to be charged\n     **/\n    function updateState(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        uint256 baseTokenSupply,\n        bytes calldata data\n    ) external payable returns (uint128 protocolFees);\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Quote functions (do not update internal state)\n\n    /**\n     * @notice calculate Synth tokens to mint given baseLiquidityIn\n     * @notice does not include fees\n     * @param mintParams covenant mint parameters\n     * @param baseTokenSupply total baseToken supply in the market\n     * @param sender sender of tokens coming in\n     * @return aTokenAmountOut amount of aToken to be minted given amountIn\n     * @return zTokenAmountOut amount of zToken to be minted given amountIn\n     * @return protocolFees calculated protocol fees to be charged\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after mint\n     **/\n    function quoteMint(\n        MintParams calldata mintParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (\n            uint256 aTokenAmountOut,\n            uint256 zTokenAmountOut,\n            uint128 protocolFees,\n            uint128 oracleUpdateFee,\n            TokenPrices memory tokenPrices\n        );\n\n    /**\n     * @notice calculates base liquidity out, given synth tokens redeemed\n     * @notice does not include fees\n     * @notice Treats amounts as exact input, and does not check for slippage\n     * @param redeemParams covenant redeem parameters\n     * @param sender sender of tokens coming in\n     * @param baseTokenSupply total baseToken supply in the market\n     * @return baseAmountOut base tokens that would come out\n     * @return protocolFees calculated protocol fees to be charged\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after redeem\n     **/\n    function quoteRedeem(\n        RedeemParams calldata redeemParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (uint256 baseAmountOut, uint128 protocolFees, uint128 oracleUpdateFee, TokenPrices memory tokenPrices);\n    /**\n     * @notice calculates swap between tokens (base or synths)\n     * @notice does not include fees\n     * @dev All parameters are given in raw token decimal encoding.\n     * @param swapParams covenant swap parameters\n     * @param sender sender of tokens coming in\n     * @param baseTokenSupply total baseToken supply in the market\n     * @return amountCalculated amount of liquidity swapped out / in, depending on whether swap is EXACT_IN / EXACT_OUT\n     * @return protocolFees calculated protocol fees to be charged\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after swap\n     **/\n    function quoteSwap(\n        SwapParams calldata swapParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (\n            uint256 amountCalculated,\n            uint128 protocolFees,\n            uint128 oracleUpdateFee,\n            TokenPrices memory tokenPrices\n        );\n}\n"
        },
        "src/libraries/Events.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.30;\n\nimport {MarketId, MarketParams, SynthTokens, TokenPrices, AssetType} from \"../interfaces/ICovenant.sol\";\n\nlibrary Events {\n    /**\n     * @dev Emitted on market creation\n     * @param marketId the market ID\n     * @param marketParams the market params\n     * @param initData additional data passed to LEX during initialization\n     * @param lexData additional data returned by LEX during initialization (ABI encoded)\n     **/\n    event CreateMarket(\n        MarketId indexed marketId,\n        MarketParams marketParams,\n        SynthTokens synthTokens,\n        bytes initData,\n        bytes lexData\n    );\n\n    /**\n     * @dev Emitted on mint\n     * @notice Event incorporates minimal price information (from which all prices can be derived)\n     * @param marketId the market indicating the aTokens / zTokens to mint given baseToken (there could be more than one market for the same baseToken)\n     * @param baseAmountIn the amount of base token to deposit (and against which to mint a and z tokens)\n     * @param sender the supplier of base Tokens\n     * @param receiver the receiver of aTokens and zTokens\n     * @param aTokenAmountOut amount of aToken minted\n     * @param zTokenAmountOut amount of zToken minted\n     * @param tokenPrices Prices, in WADS, of baseToken, aToken and zToken after action (denominated in Quote tokens)\n     **/\n    event Mint(\n        MarketId indexed marketId,\n        uint256 baseAmountIn,\n        address indexed sender,\n        address indexed receiver,\n        uint256 aTokenAmountOut,\n        uint256 zTokenAmountOut,\n        uint128 protocolFees,\n        TokenPrices tokenPrices\n    );\n\n    /**\n     * @dev Emitted on redeem\n     * @param marketId the market for which the aTokens / zTokens will be redeemed for baseToken\n     * @param aTokenAmountIn the aTokenAmount being redeemed / burned (exact in)\n     * @param zTokenAmountIn the zTokenAmount being redeemed / burned (exact in)\n     * @param sender the supplier of a and z tokens\n     * @param receiver the receiver of base tokens\n     * @param amountOut amount of base tokens sent out to receiver\n     * @param tokenPrices Prices, in WADS, of baseToken, aToken and zToken after action (denominated in Quote tokens)\n     **/\n    event Redeem(\n        MarketId indexed marketId,\n        uint256 aTokenAmountIn,\n        uint256 zTokenAmountIn,\n        address indexed sender,\n        address indexed receiver,\n        uint256 amountOut,\n        uint128 protocolFees,\n        TokenPrices tokenPrices\n    );\n\n    /**\n     * @dev Emitted on swap\n     * @param marketId the market in which the swap is executed\n     * @param assetIn type of token swapped in\n     * @param assetOut type of token swapped out\n     * @param amountIn amount of tokenIn received and burned by market during swap\n     * @param amountOut amount of tokenOut minted and sent by market during swap\n     * @param sender the supplier of tokenIn\n     * @param receiver the receiver of tokenOut\n     * @param tokenPrices Prices, in WADS, of baseToken, aToken and zToken after action (denominated in Quote tokens)\n     **/\n    event Swap(\n        MarketId indexed marketId,\n        AssetType assetIn,\n        AssetType assetOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        address indexed sender,\n        address indexed receiver,\n        uint128 protocolFees,\n        TokenPrices tokenPrices\n    );\n\n    /**\n     * @dev Emitted on LEX update\n     * @param LEXImplementationAddress address of lex logic implementation\n     * @param isEnabled whether the address is a valid implementation for new markets\n     **/\n    event UpdateEnabledLEX(address indexed LEXImplementationAddress, bool isEnabled);\n\n    /**\n     * @dev Emitted on Oracle update\n     * @param oracle address of oracle\n     * @param isEnabled whether the address is a valid oracle for new markets\n     **/\n    event UpdateEnabledOracle(address indexed oracle, bool isEnabled);\n\n    /**\n     * @dev Emitted on update of default protocol fee\n     * @param oldDefaultFee old default fee\n     * @param newDefaultFee new default fee\n     **/\n    event UpdateDefaultProtocolFee(uint32 oldDefaultFee, uint32 newDefaultFee);\n\n    /**\n     * @dev Emitted on update of a market protocol fee\n     * @param marketId market being updated\n     * @param oldMarketFee old default fee\n     * @param newMarketFee new default fee\n     **/\n    event UpdateMarketProtocolFee(MarketId indexed marketId, uint32 oldMarketFee, uint32 newMarketFee);\n\n    /**\n     * @dev Emitted when protocol fees are collected\n     * @param marketId market from which fees are being collected\n     * @param recipient recipient of collected fees\n     * @param asset asset in which fees are denominated\n     * @param amount amount collected\n     **/\n    event CollectProtocolFee(MarketId indexed marketId, address recipient, address asset, uint128 amount);\n\n    /**\n     * @dev Emitted when protocol is paused or unpaused\n     * @param marketId market from which fees are being collected\n     * @param isPaused whether the market is paused\n     **/\n    event MarketPaused(MarketId indexed marketId, bool isPaused);\n\n    /**\n     * @dev Emitted when default pause address is updated\n     * @param oldDefaultPauseAddress old default pause address\n     * @param newDefaultPauseAddress new default pause address\n     **/\n    event UpdateDefaultPauseAddress(address oldDefaultPauseAddress, address newDefaultPauseAddress);\n\n    /**\n     * @dev Emitted when authorized pause address for a market is updated\n     * @param marketId market from which pause address is being updated\n     * @param oldPauseAddress old authorized pause address\n     * @param newPauseAddress new authorized pause address\n     **/\n    event UpdateMarketPauseAddress(MarketId indexed marketId, address oldPauseAddress, address newPauseAddress);\n}\n"
        },
        "src/libraries/Errors.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.30;\n\nlibrary Errors {\n    error E_ZeroAmount(); // 0xaf4935be\n    error E_ZeroAddress(); // 0x459f5f6e\n    error E_CrossedLimit(); // 0xb8775684\n    error E_InsufficientAmount(); // 0x9950c184\n    error E_IncorrectMarketAsset(); // 0x76ba676e\n    error E_EqualSwapAssets(); // 0x213a0fd0\n    error E_MarketLocked(); // 0x8a7ede1f\n    error E_MarketPaused(); // 0xed9c479e\n    error E_MarketNonExistent(); // 0xe2f65643\n    error E_LEXimplementationNotAuthorized(); // 0xb4ee3f59\n    error E_CuratorNotAuthorized(); // 0x808c99be\n    error E_MarketAlreadyExists(); // 0x601494a7\n    error E_IncorrectMarketParams(); // 0x7f6cd0c7\n    error E_Unauthorized(); // 0x08e2ce17\n    error E_IncorrectPayment(); // 0xa705df45\n    error E_ProtocolFeeTooHigh(); // 0xc886fec7\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "@std/=lib/forge-std/src/",
            "@clones/=lib/clones-with-immutable-args/src/",
            "@chainlink/=lib/chainlink-brownie-contracts/",
            "@openzeppelin/=lib/openzeppelin-contracts/contracts/",
            "@solady/=lib/solady/src/",
            "@aave/=lib/aave-v3-core/contracts/protocol/",
            "@euler-price-oracle/=lib/euler-price-oracle/src/",
            "aave-v3-core/=lib/aave-v3-core/",
            "forge-std/=lib/forge-std/src/",
            "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
            "chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/contracts/src/v0.6/vendor/@arbitrum/nitro-contracts/src/",
            "clones-with-immutable-args/=lib/clones-with-immutable-args/src/",
            "ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/",
            "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
            "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
            "openzeppelin-contracts/=lib/openzeppelin-contracts/",
            "solady/=lib/solady/src/",
            "@pendle/core-v2/=lib/euler-price-oracle/lib/pendle-core-v2-public/contracts/",
            "@pyth/=lib/euler-price-oracle/lib/pyth-sdk-solidity/",
            "@redstone/evm-connector/=lib/euler-price-oracle/lib/redstone-oracles-monorepo/packages/evm-connector/contracts/",
            "@uniswap/v3-core/=lib/euler-price-oracle/lib/v3-core/",
            "@uniswap/v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/",
            "ethereum-vault-connector/=lib/euler-price-oracle/lib/ethereum-vault-connector/",
            "euler-price-oracle/=lib/euler-price-oracle/src/",
            "openzeppelin/=lib/euler-price-oracle/lib/openzeppelin-contracts/contracts/",
            "pendle-core-v2-public/=lib/euler-price-oracle/lib/pendle-core-v2-public/contracts/",
            "pyth-sdk-solidity/=lib/pyth-sdk-solidity/",
            "redstone-oracles-monorepo/=lib/euler-price-oracle/lib/",
            "v3-core/=lib/euler-price-oracle/lib/v3-core/contracts/",
            "v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/contracts/"
        ],
        "optimizer": {
            "enabled": true,
            "runs": 3750
        },
        "metadata": {
            "useLiteralContent": false,
            "bytecodeHash": "ipfs",
            "appendCBOR": true
        },
        "outputSelection": {
            "*": {
                "": ["ast"],
                "*": [
                    "abi",
                    "evm.bytecode.object",
                    "evm.bytecode.sourceMap",
                    "evm.bytecode.linkReferences",
                    "evm.deployedBytecode.object",
                    "evm.deployedBytecode.sourceMap",
                    "evm.deployedBytecode.linkReferences",
                    "evm.deployedBytecode.immutableReferences",
                    "evm.methodIdentifiers",
                    "ir",
                    "irOptimized",
                    "metadata",
                    "irOptimizedAst"
                ]
            }
        },
        "evmVersion": "cancun",
        "viaIR": false,
        "libraries": {}
    }
}
