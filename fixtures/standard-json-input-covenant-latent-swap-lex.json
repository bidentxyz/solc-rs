{
    "language": "Solidity",
    "sources": {
        "src/lex/latentswap/LatentSwapLEX.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {ILatentSwapLEX, LexState, LexConfig, AssetType, MintParams, RedeemParams, SwapParams, MarketId, MarketParams, TokenPrices, SynthTokens, LexParams} from \"./interfaces/ILatentSwapLEX.sol\";\nimport {ILiquidExchangeModel} from \"../../interfaces/ILiquidExchangeModel.sol\";\nimport {ISynthToken, IERC20} from \"../../interfaces/ISynthToken.sol\";\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {ITokenData} from \"./interfaces/ITokenData.sol\";\nimport {TokenData} from \"./libraries/TokenData.sol\";\nimport {FixedPoint} from \"./libraries/FixedPoint.sol\";\nimport {LSErrors} from \"./libraries/LSErrors.sol\";\nimport {LatentSwapLogic} from \"./libraries/LatentSwapLogic.sol\";\nimport {SynthToken} from \"../../synths/SynthToken.sol\";\nimport {Ownable2Step, Ownable} from \"@openzeppelin/access/Ownable2Step.sol\";\n\n/**\n * @title Latent Swap LEX\n * @author Covenant Labs\n **/\n\n/**\n * @dev Emitted when default noCapLimit is set for a token\n * @param token the token address\n * @param oldDefaultNoCapLimit the old default noCapLimit for markets with this quote token\n * @param newDefaultNoCapLimit the new default noCapLimit for markets with this quote token\n **/\nevent SetDefaultNoCapLimit(address indexed token, uint8 oldDefaultNoCapLimit, uint8 newDefaultNoCapLimit);\nevent SetMarketNoCapLimit(MarketId indexed marketId, uint8 oldNoCapLimit, uint8 newNoCapLimit);\n\ncontract LatentSwapLEX is ILatentSwapLEX, TokenData, Ownable2Step {\n    /// @inheritdoc ILiquidExchangeModel\n    string public constant name = \"LatentSwap V1.0\"; // LEX name\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Constants and immutables\n    uint16 constant MAX_LIMIT_LTV = 9999; // 99.99% max limit LTV, above which aTokens cannot be minted.\n    uint104 constant MAX_SQRTPRICE = uint104(8 * FixedPoint.Q96); // 64 max DEX price\n    uint104 constant MIN_SQRTPRICE = uint104(FixedPoint.Q96 / 32); // 0.001 min DEX price\n    uint104 constant MIN_SQRTPRICE_RATIO = uint104((1004 * FixedPoint.Q96) / 1000); // (1.0001)^80 MIN price width = 1.004 MIN sqrt price ratio.  Given this,  max market concentration is max 2^8. ie, Liquidity <= (BaseTokenValue * 2^8)\n    int64 constant MAX_LN_RATE_BIAS = 405465108108164000; // ln(1.5) in WADs -> 50% max rate bias\n    int64 constant MIN_LN_RATE_BIAS = -223143551314209704; // ln(0.8) in WADs -> -20% min rate bias\n    uint32 constant MIN_DURATION = 1 days; // 1 day (in seconds)\n    uint8 constant DEBT = 0; // used for indexing into supplyAmounts and dexAmounts\n    uint8 constant LVRG = 1; // used for indexing into supplyAmounts and dexAmounts\n\n    // Immutables\n    address internal immutable _covenantCore;\n    int64 internal immutable _initLnRateBias; // ln of initial rate bias (WADs)\n    uint160 internal immutable _edgeSqrtPriceX96_B; // high edge of concentrated liquidity\n    uint160 internal immutable _edgeSqrtPriceX96_A; // low edge of concentrated liquidity\n    uint160 internal immutable _limHighSqrtPriceX96; // from which _highLTV can be derived (no aToken sales, no zToken buys)\n    uint160 internal immutable _limMaxSqrtPriceX96; // from which _maxLTV can be derived (same as _highLTV && no aToken buys)\n    uint32 internal immutable _debtDuration; // perpetual duration of debt, in seconds (max 100 years)\n    uint8 internal immutable _swapFee; // BPS fee when swapping tokens.  Max of 2.55% swap fee\n\n    // pre-calculated values\n    uint256 internal immutable _targetXvsL; // pre-calculated static value, X96 precision\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Storage\n\n    // Map of Lex market states (marketId to data)\n    mapping(MarketId marketId => LexState) internal lexState;\n\n    // Map of Lex market configs (marketId to data)\n    mapping(MarketId marketId => LexConfig) internal lexConfig;\n\n    // Map of default NoCapLimit overrides for specific token addresses\n    mapping(address token => uint8) internal tokenNoCapLimit;\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    modifier onlyCovenantCore() {\n        if (_covenantCore != _msgSender()) revert LSErrors.E_LEX_OnlyCovenantCanCall();\n        _;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Constructor\n\n    constructor(\n        address initialOwner_,\n        address covenantCore_,\n        uint160 edgeHighSqrtPriceX96_,\n        uint160 edgeLowSqrtPriceX96_,\n        uint160 limHighSqrtPriceX96_,\n        uint160 limMaxSqrtPriceX96_,\n        int64 initLnRateBias_,\n        uint32 debtDuration_,\n        uint8 swapFee_\n    ) Ownable(initialOwner_) {\n        // checks\n        if (covenantCore_ == address(0)) revert LSErrors.E_LEX_ZeroAddress();\n\n        // Check correct price ordering\n        if (edgeHighSqrtPriceX96_ < limMaxSqrtPriceX96_) revert LSErrors.E_LEX_IncorrectInitializationPrice();\n        if (limMaxSqrtPriceX96_ <= limHighSqrtPriceX96_) revert LSErrors.E_LEX_IncorrectInitializationPrice();\n        if (limHighSqrtPriceX96_ <= FixedPoint.Q96) revert LSErrors.E_LEX_IncorrectInitializationPrice();\n        if (FixedPoint.Q96 < edgeLowSqrtPriceX96_) revert LSErrors.E_LEX_IncorrectInitializationPrice();\n        if (initLnRateBias_ > MAX_LN_RATE_BIAS || initLnRateBias_ < MIN_LN_RATE_BIAS)\n            revert LSErrors.E_LEX_IncorrectInitializationLnRateBias();\n        if (debtDuration_ < MIN_DURATION) revert LSErrors.E_LEX_IncorrectInitializationDuration();\n\n        // check vs hardcoded limits\n        if (edgeHighSqrtPriceX96_ > MAX_SQRTPRICE) revert LSErrors.E_LEX_IncorrectInitializationPrice();\n        if (edgeLowSqrtPriceX96_ < MIN_SQRTPRICE) revert LSErrors.E_LEX_IncorrectInitializationPrice();\n        if (((edgeHighSqrtPriceX96_ * FixedPoint.Q96) / edgeLowSqrtPriceX96_) < MIN_SQRTPRICE_RATIO)\n            revert LSErrors.E_LEX_IncorrectInitializationPrice();\n\n        // calculate maxLTV and target_dXdL_X96\n        (uint256 maxLTV, uint256 target_dXdL_X96) = LatentSwapLogic.computeMaxLTVandTargetdXdL(\n            edgeLowSqrtPriceX96_,\n            edgeHighSqrtPriceX96_,\n            limMaxSqrtPriceX96_\n        );\n\n        // check limMax <= MAX_LIMIT_LTV\n        if (maxLTV > MAX_LIMIT_LTV) revert LSErrors.E_LEX_IncorrectInitializationPrice();\n\n        // set implementation immutables\n        _covenantCore = covenantCore_;\n        _edgeSqrtPriceX96_B = edgeHighSqrtPriceX96_;\n        _edgeSqrtPriceX96_A = edgeLowSqrtPriceX96_;\n        _limHighSqrtPriceX96 = limHighSqrtPriceX96_;\n        _limMaxSqrtPriceX96 = limMaxSqrtPriceX96_;\n        _initLnRateBias = initLnRateBias_;\n        _debtDuration = debtDuration_;\n        _swapFee = swapFee_;\n\n        // Pre-calculate static values\n        // This is equivalent to dX/dL at the target price of 1\n        _targetXvsL = target_dXdL_X96;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // OnlyOwner functions\n\n    /// @inheritdoc ILatentSwapLEX\n    function setDefaultNoCapLimit(address token, uint8 newDefaultMintRedeemNoCap) external onlyOwner {\n        // @dev - if defaultMintRedeemNoCap == 0, new markets will use 1 baseToken as the MintRedeemNoCap as the default\n        uint8 oldDefaulNoCapLimit = tokenNoCapLimit[token];\n        tokenNoCapLimit[token] = newDefaultMintRedeemNoCap;\n        emit SetDefaultNoCapLimit(token, oldDefaulNoCapLimit, newDefaultMintRedeemNoCap);\n    }\n\n    /// @inheritdoc ILatentSwapLEX\n    function setMarketNoCapLimit(MarketId marketId, uint8 newNoCapLimit) external onlyOwner {\n        if (lexConfig[marketId].aToken == address(0)) revert LSErrors.E_LEX_MarketDoesNotExist();\n        uint8 oldNoCapLimit = lexConfig[marketId].noCapLimit;\n        lexConfig[marketId].noCapLimit = newNoCapLimit;\n        emit SetMarketNoCapLimit(marketId, oldNoCapLimit, newNoCapLimit);\n    }\n\n    function setQuoteTokenDecimalsOverrideForNewMarkets(address asset, uint8 newDecimals) external onlyOwner {\n        _updateAssetDecimals(asset, newDecimals);\n    }\n\n    function setQuoteTokenSymbolOverrideForNewMarkets(address asset, string calldata newSymbol) external onlyOwner {\n        _updateAssetSymbol(asset, newSymbol);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // ILiquidExchangeModel Getters\n\n    /// @inheritdoc ILiquidExchangeModel\n    function getProtocolFee(MarketId marketId) external view returns (uint32) {\n        return lexConfig[marketId].protocolFee;\n    }\n\n    /// @inheritdoc ILiquidExchangeModel\n    function getSynthTokens(MarketId marketId) external view returns (SynthTokens memory synthTokens) {\n        synthTokens.aToken = lexConfig[marketId].aToken;\n        synthTokens.zToken = lexConfig[marketId].zToken;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // ILatentSwapLEX Getters\n\n    /// @inheritdoc ILatentSwapLEX\n    function getLexParams() external view returns (LexParams memory) {\n        return _lexParams();\n    }\n\n    /// @inheritdoc ILatentSwapLEX\n    function getLexState(MarketId marketId) external view returns (LexState memory) {\n        return lexState[marketId];\n    }\n\n    /// @inheritdoc ILatentSwapLEX\n    function getLexConfig(MarketId marketId) external view returns (LexConfig memory) {\n        return lexConfig[marketId];\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // CovenantCore actions\n\n    /// @inheritdoc ILiquidExchangeModel\n    function initMarket(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        uint32 protocolFee,\n        bytes calldata initData\n    ) external onlyCovenantCore returns (SynthTokens memory synthTokens, bytes memory lexData) {\n        if (lexConfig[marketId].aToken != address(0)) revert LSErrors.E_LEX_AlreadyInitialized();\n\n        LatentSwapLogic.MarketInitInfo memory info = LatentSwapLogic.getInitMarketInfo(\n            marketParams,\n            _debtDuration,\n            _edgeSqrtPriceX96_A,\n            _edgeSqrtPriceX96_B,\n            tokenNoCapLimit[marketParams.baseToken],\n            _assetDecimals(marketParams.quoteToken),\n            _assetSymbol(marketParams.quoteToken)\n        );\n\n        // Create new leverage synth token\n        // e.g., Symbol: ETHx2.USDT  Name: ETH x2 Leverage Coin (USDT/3M)\n        synthTokens.aToken = address(\n            new SynthToken(\n                _covenantCore,\n                address(this),\n                marketId,\n                IERC20(marketParams.baseToken),\n                AssetType.LEVERAGE,\n                info.aTokenName,\n                info.aTokenSymbol,\n                info.synthDecimals\n            )\n        );\n\n        // Create new debt synth token\n        // e.g., Symbol: USDT.bETH  Name: USDT ETH-backed Margin Coin (x2/3M)\n        synthTokens.zToken = address(\n            new SynthToken(\n                _covenantCore,\n                address(this),\n                marketId,\n                IERC20(marketParams.baseToken),\n                AssetType.DEBT,\n                info.zTokenName,\n                info.zTokenSymbol,\n                info.synthDecimals\n            )\n        );\n\n        // Read oracle (current market price) - revert on error\n        // @dev this can revert if the Oracle does not return a price, or if\n        // price * (1/_targetXvsL) * (10 ^ (vars.synthDecimals - vars.quoteDecimals)) is too small\n        // given oracle price being too low given other market parameters\n        (uint256 currentBasePrice, ) = LatentSwapLogic.readBasePriceAndCalculateLiqRatio(\n            marketParams,\n            _targetXvsL,\n            int8(info.quoteDecimals) - int8(info.synthDecimals),\n            false\n        );\n\n        // Initialize lex config\n        lexConfig[marketId] = LexConfig({\n            aToken: synthTokens.aToken,\n            zToken: synthTokens.zToken,\n            protocolFee: protocolFee,\n            noCapLimit: info.noCapLimit,\n            scaleDecimals: int8(info.quoteDecimals) - int8(info.synthDecimals),\n            adaptive: false\n        });\n\n        // Initialize lex state\n        lexState[marketId] = LexState({\n            lastBaseTokenPrice: currentBasePrice,\n            lastDebtNotionalPrice: FixedPoint.WAD, //Notice: Upon market initialization, 1 zToken = 1 quoteToken in value\n            lastLnRateBias: _initLnRateBias,\n            lastETWAPBaseSupply: 0,\n            lastSqrtPriceX96: uint160(FixedPoint.Q96), //Notice: Upon market initialization, market is at target LTV\n            lastUpdateTimestamp: uint96(block.timestamp)\n        });\n    }\n\n    /// @inheritdoc ILiquidExchangeModel\n    function setMarketProtocolFee(MarketId marketId, uint32 newFee) external onlyCovenantCore {\n        lexConfig[marketId].protocolFee = newFee;\n    }\n\n    /// @inheritdoc ILiquidExchangeModel\n    // @Notice. When depositing baseTokens, how many aTokens and zTokens should be minted?\n    // Target is not to have price impact from this operation, so minted amounts are all proportional\n    // @dev - sender address not used (left empty)\n    function mint(\n        MintParams calldata mintParams,\n        address,\n        uint256 baseTokenSupply\n    )\n        external\n        payable\n        onlyCovenantCore\n        returns (uint256 aTokenAmountOut, uint256 zTokenAmountOut, uint128 protocolFees, TokenPrices memory tokenPrices)\n    {\n        // Update oracle price if necessary (external call and storage write)\n        _updateOraclePrice(mintParams.marketParams, mintParams.data);\n\n        ///////////////////////////////\n        // Mint logic\n        LatentSwapLogic.LexFullState memory currentState;\n        (currentState, tokenPrices, aTokenAmountOut, zTokenAmountOut) = LatentSwapLogic.mintLogic(\n            mintParams,\n            _lexParams(),\n            lexConfig[mintParams.marketId],\n            lexState[mintParams.marketId],\n            baseTokenSupply,\n            false\n        );\n\n        ///////////////////////////////\n        // Write changes (storage writes)\n\n        // Mint aTokens / zTokens (storage write)\n        ISynthToken(currentState.lexConfig.aToken).lexMint(mintParams.to, aTokenAmountOut);\n        ISynthToken(currentState.lexConfig.zToken).lexMint(mintParams.to, zTokenAmountOut);\n\n        // Update lex state (storage write)\n        lexState[mintParams.marketId] = currentState.lexState;\n\n        return (aTokenAmountOut, zTokenAmountOut, currentState.accruedProtocolFee, tokenPrices);\n    }\n\n    /// @inheritdoc ILiquidExchangeModel\n    // @Notice. When redeeming baseTokens, we might require to swap aTokens for zTokens before doing a balanced redeem operation\n    // We calculate amount of baseTokens redeemed using stableMath logic.\n    function redeem(\n        RedeemParams calldata redeemParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        payable\n        onlyCovenantCore\n        returns (uint256 amountOut, uint128 protocolFees, TokenPrices memory tokenPrices)\n    {\n        // Update oracle price if necessary (external call and storage write) and check for overdeposit\n        _updateOraclePrice(redeemParams.marketParams, redeemParams.data);\n\n        ///////////////////////////////\n        // Redeem logic\n        LatentSwapLogic.LexFullState memory currentState;\n        (currentState, tokenPrices, amountOut) = LatentSwapLogic.redeemLogic(\n            redeemParams,\n            _lexParams(),\n            lexConfig[redeemParams.marketId],\n            lexState[redeemParams.marketId],\n            baseTokenSupply,\n            false\n        );\n\n        ///////////////////////////////\n        // Write changes (storage writes)\n\n        // Burn aTokens / zTokens (storage write)\n        ISynthToken(currentState.lexConfig.aToken).lexBurn(sender, redeemParams.aTokenAmountIn);\n        ISynthToken(currentState.lexConfig.zToken).lexBurn(sender, redeemParams.zTokenAmountIn);\n\n        // Update lex state (storage write)\n        lexState[redeemParams.marketId] = currentState.lexState;\n\n        return (amountOut, currentState.accruedProtocolFee, tokenPrices);\n    }\n\n    /// @inheritdoc ILiquidExchangeModel\n    function swap(\n        SwapParams calldata swapParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        payable\n        onlyCovenantCore\n        returns (uint256 amountCalculated, uint128 protocolFees, TokenPrices memory tokenPrices)\n    {\n        // Update oracle price if necessary (external call and storage write) and check for overdeposit\n        _updateOraclePrice(swapParams.marketParams, swapParams.data);\n\n        ///////////////////////////////\n        // Swap logic\n        LatentSwapLogic.LexFullState memory currentState;\n        (currentState, tokenPrices, amountCalculated) = LatentSwapLogic.swapLogic(\n            swapParams,\n            _lexParams(),\n            lexConfig[swapParams.marketId],\n            lexState[swapParams.marketId],\n            baseTokenSupply,\n            false\n        );\n\n        ///////////////////////////////\n        // Write changes (storage writes)\n\n        // Burn aTokens / zTokens coming in (storage write in trusted external call)\n        if (swapParams.assetIn != AssetType.BASE)\n            ISynthToken(\n                (swapParams.assetIn == AssetType.DEBT) ? currentState.lexConfig.zToken : currentState.lexConfig.aToken\n            ).lexBurn(sender, (swapParams.isExactIn) ? swapParams.amountSpecified : amountCalculated);\n        // Mint aTokens / zTokens going out (storage write in trusted external call)\n        if (swapParams.assetOut != AssetType.BASE)\n            ISynthToken(\n                (swapParams.assetOut == AssetType.DEBT) ? currentState.lexConfig.zToken : currentState.lexConfig.aToken\n            ).lexMint(swapParams.to, (swapParams.isExactIn) ? amountCalculated : swapParams.amountSpecified);\n\n        // Update lex state (storage write)\n        lexState[swapParams.marketId] = currentState.lexState;\n\n        return (amountCalculated, currentState.accruedProtocolFee, tokenPrices);\n    }\n\n    /// @inheritdoc ILiquidExchangeModel\n    function updateState(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        uint256 baseTokenSupply,\n        bytes calldata data\n    ) external payable onlyCovenantCore returns (uint128 protocolFees) {\n        // Update oracle price if necessary (external call and storage write) and check for overdeposit\n        _updateOraclePrice(marketParams, data);\n\n        // Calculate market state (storage read)\n        LatentSwapLogic.LexFullState memory currentState = LatentSwapLogic.calculateMarketState(\n            marketParams,\n            _lexParams(),\n            lexConfig[marketId],\n            lexState[marketId],\n            baseTokenSupply,\n            false\n        );\n\n        // Update lex state (storage write)\n        lexState[marketId] = currentState.lexState;\n\n        return currentState.accruedProtocolFee;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Quotes\n\n    /// @inheritdoc ILiquidExchangeModel\n    function quoteMint(\n        MintParams calldata mintParams,\n        address,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (\n            uint256 aTokenAmountOut,\n            uint256 zTokenAmountOut,\n            uint128 protocolFees,\n            uint128 oracleUpdateFee,\n            TokenPrices memory tokenPrices\n        )\n    {\n        oracleUpdateFee = _getOracleUpdateFee(mintParams.marketParams, mintParams.data); // Get oracle update fee, if any\n        LatentSwapLogic.LexFullState memory currentState;\n        (currentState, tokenPrices, aTokenAmountOut, zTokenAmountOut) = LatentSwapLogic.mintLogic(\n            mintParams,\n            _lexParams(),\n            lexConfig[mintParams.marketId],\n            lexState[mintParams.marketId],\n            baseTokenSupply,\n            true\n        );\n        return (aTokenAmountOut, zTokenAmountOut, currentState.accruedProtocolFee, oracleUpdateFee, tokenPrices);\n    }\n\n    /// @inheritdoc ILiquidExchangeModel\n    function quoteRedeem(\n        RedeemParams calldata redeemParams,\n        address,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (uint256 amountOut, uint128 protocolFees, uint128 oracleUpdateFee, TokenPrices memory tokenPrices)\n    {\n        oracleUpdateFee = _getOracleUpdateFee(redeemParams.marketParams, redeemParams.data); // Get oracle update fee, if any\n        LatentSwapLogic.LexFullState memory currentState;\n        (currentState, tokenPrices, amountOut) = LatentSwapLogic.redeemLogic(\n            redeemParams,\n            _lexParams(),\n            lexConfig[redeemParams.marketId],\n            lexState[redeemParams.marketId],\n            baseTokenSupply,\n            true\n        );\n        return (amountOut, currentState.accruedProtocolFee, oracleUpdateFee, tokenPrices);\n    }\n\n    /// @inheritdoc ILiquidExchangeModel\n    function quoteSwap(\n        SwapParams calldata swapParams,\n        address,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (\n            uint256 amountCalculated,\n            uint128 protocolFees,\n            uint128 oracleUpdateFee,\n            TokenPrices memory tokenPrices\n        )\n    {\n        oracleUpdateFee = _getOracleUpdateFee(swapParams.marketParams, swapParams.data); // Get oracle update fee, if any\n        LatentSwapLogic.LexFullState memory currentState;\n        (currentState, tokenPrices, amountCalculated) = LatentSwapLogic.swapLogic(\n            swapParams,\n            _lexParams(),\n            lexConfig[swapParams.marketId],\n            lexState[swapParams.marketId],\n            baseTokenSupply,\n            true\n        );\n        return (amountCalculated, currentState.accruedProtocolFee, oracleUpdateFee, tokenPrices);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Internal functions\n\n    function _lexParams() internal view returns (LexParams memory lexParams) {\n        return\n            LexParams({\n                covenantCore: _covenantCore,\n                initLnRateBias: _initLnRateBias, // Init rate bias (in LN terms, WADs)\n                edgeSqrtPriceX96_B: _edgeSqrtPriceX96_B, // high edge of concentrated liquidity\n                edgeSqrtPriceX96_A: _edgeSqrtPriceX96_A, // low edge of concentrated liquidity\n                limHighSqrtPriceX96: _limHighSqrtPriceX96, // from which _highLTV can be derived (no aToken sales, no zToken buys)\n                limMaxSqrtPriceX96: _limMaxSqrtPriceX96, // from which _maxLTV can be derived (same as _highLTV && no aToken buys)\n                debtDuration: _debtDuration, // perpetual duration of debt, in seconds (max 100 years)\n                swapFee: _swapFee, // BPS fee when swapping tokens.  Max of 2.55% swap fee\n                targetXvsL: _targetXvsL // pre-calculated liquidity concentration\n            });\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Pull Oracle functions\n\n    // updatePrices if there is data\n    function _updateOraclePrice(MarketParams calldata marketParams, bytes calldata data) internal {\n        // send data package and msgValue to Oracle, if data was sent\n        if (data.length > 0)\n            IPriceOracle(marketParams.curator).updatePriceFeeds{value: msg.value}(\n                marketParams.baseToken,\n                marketParams.quoteToken,\n                data\n            );\n        else if (msg.value > 0) revert LSErrors.E_LEX_Overdeposit();\n    }\n\n    function _getOracleUpdateFee(\n        MarketParams calldata marketParams,\n        bytes calldata data\n    ) internal view returns (uint128 oracleFee) {\n        return\n            (data.length > 0)\n                ? IPriceOracle(marketParams.curator).getUpdateFee(marketParams.baseToken, marketParams.quoteToken, data)\n                : 0;\n    }\n}\n"
        },
        "src/lex/latentswap/interfaces/ILatentSwapLEX.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ILiquidExchangeModel, AssetType, MintParams, RedeemParams, SwapParams, MarketId, MarketParams, TokenPrices, SynthTokens} from \"src/interfaces/ILiquidExchangeModel.sol\";\n\nstruct LexState {\n    uint256 lastDebtNotionalPrice; // WAD units\n    uint256 lastBaseTokenPrice; // Last oracle read WAD units\n    uint256 lastETWAPBaseSupply; // Tracks baseSupply for redeem cap\n    uint160 lastSqrtPriceX96; // Last DEX price, X96 units\n    uint96 lastUpdateTimestamp; // Timestamp in seconds\n    int64 lastLnRateBias; // WAD units.\n}\n\nstruct LexConfig {\n    uint32 protocolFee; // Protocol fees in BPS units (uint16 tvlFee, uint16 yieldFee)\n    address aToken;\n    address zToken;\n    uint8 noCapLimit; // Max liquidity mint / burn without a cap limit.  Limit = 2^noCapLimit\n    int8 scaleDecimals; // Scale decimals (used for scaling the price from the oracle)\n    bool adaptive; // Whether debtPriceDiscountBalanced is adaptive\n}\n\nstruct LexParams {\n    address covenantCore;\n    int64 initLnRateBias;\n    uint160 edgeSqrtPriceX96_B; // high edge of concentrated liquidity\n    uint160 edgeSqrtPriceX96_A; // low edge of concentrated liquidity\n    uint160 limHighSqrtPriceX96; // from which _highLTV can be derived (no aToken sales, no zToken buys)\n    uint160 limMaxSqrtPriceX96; // from which _maxLTV can be derived (same as _highLTV && no aToken buys)\n    uint32 debtDuration; // perpetual duration of debt, in seconds (max 100 years)\n    uint8 swapFee; // BPS fee when swapping tokens.  Max of 2.55% swap fee\n    uint256 targetXvsL; // pre-calculated static value\n}\n\n/**\n * @title ILatentSwapLEX\n * @author Covenant Labs\n * @notice Defines the interface for ILatentSwapLEX.sol\n **/\ninterface ILatentSwapLEX is ILiquidExchangeModel {\n    ///////////////////////////////////////////////////////////////////////////////\n    // Getters\n\n    /// @notice LexParams (constructor) getter\n    function getLexParams() external view returns (LexParams memory);\n\n    /// @notice LexState getter\n    function getLexState(MarketId marketId) external view returns (LexState memory);\n\n    /// @notice LexConfig getter\n    function getLexConfig(MarketId marketId) external view returns (LexConfig memory);\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Write functions (only Owner calls)\n\n    /// @notice sets default noCapDecimals for a quote token\n    /// @dev setting noCapLimit = 255 removes mint / redeem restriction for markets using this quoteToken\n    /// @param token the quote token address\n    /// @param newDefaultNoCapLimit the default noCapLimit for markets with this quote token\n    function setDefaultNoCapLimit(address token, uint8 newDefaultNoCapLimit) external;\n\n    /// @notice updates the noCapDecimals for a live market\n    /// @dev this is useful when the market is live and the quote token is not an actual ERC20\n    /// @dev setting noCapLimit = 255 removes mint / redeem restriction for the market\n    /// @param marketId the market id\n    /// @param newNoCapLimit the noCapLimit for the market (in power of 2).  Markets can mint and redeem baseTokens\n    //  wihout mint and redeem caps if baseTokenSupply < 2^nowCapLimt.\n    function setMarketNoCapLimit(MarketId marketId, uint8 newNoCapLimit) external;\n}\n"
        },
        "src/interfaces/ILiquidExchangeModel.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {AssetType, MintParams, RedeemParams, SwapParams, MarketId, MarketParams, TokenPrices, SynthTokens} from \"./ICovenant.sol\";\n\n/**\n * @title ILiquidExchangeModel\n * @author Covenant Labs\n * @notice Defines the the core interface of Liquid Exchange Models\n **/\ninterface ILiquidExchangeModel {\n    ///////////////////////////////////////////////////////////////////////////////\n    // Getters\n\n    /// @notice ProtocolFee getter\n    function getProtocolFee(MarketId marketId) external view returns (uint32);\n\n    /// @notice SynthTokens getter\n    function getSynthTokens(MarketId marketId) external view returns (SynthTokens memory);\n\n    /// @notice LEX name getter\n    function name() external view returns (string memory);\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Write functions (only Covenant calls)\n\n    /// @notice sets protocol Fee for a given market\n    function setMarketProtocolFee(MarketId marketId, uint32 newFee) external;\n\n    /// @notice initializes LEX variables for a market\n    function initMarket(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        uint32 protocolFee,\n        bytes memory initData\n    ) external returns (SynthTokens memory, bytes memory);\n\n    /**\n     * @notice calculate Synth tokens to mint given baseLiquidityIn, and updates internal states.\n     * @notice does not include fees\n     * @param mintParams covenant mint parameters\n     * @param baseTokenSupply total baseToken supply in the market\n     * @param sender sender of tokens coming in\n     * @return aTokenAmountOut amount of aToken to be minted given amountIn\n     * @return zTokenAmountOut amount of zToken to be minted given amountIn\n     * @return protocolFees calculated protocol fees to be charged\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after mint\n     **/\n    function mint(\n        MintParams calldata mintParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        payable\n        returns (\n            uint256 aTokenAmountOut,\n            uint256 zTokenAmountOut,\n            uint128 protocolFees,\n            TokenPrices memory tokenPrices\n        );\n\n    /**\n     * @notice calculates base liquidity out, given synth tokens redeemed, and updates internal states\n     * @notice does not include fees\n     * @notice Treats amounts as exact input, and does not check for slippage\n     * @param redeemParams covenant redeem parameters\n     * @param sender sender of tokens coming in\n     * @param baseTokenSupply total baseToken supply in the market\n     * @return amountOut amount of base token being redeemed\n     * @return protocolFees calculated protocol fees to be charged\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after redeem\n     **/\n    function redeem(\n        RedeemParams calldata redeemParams,\n        address sender,\n        uint256 baseTokenSupply\n    ) external payable returns (uint256 amountOut, uint128 protocolFees, TokenPrices memory tokenPrices);\n\n    /**\n     * @notice calculates swap between tokens (base or synths), and updates internal states\n     * @notice does not include fees\n     * @dev All parameters are given in raw token decimal encoding.\n     * @param swapParams covenant swap parameters\n     * @param sender sender of tokens coming in\n     * @param baseTokenSupply total baseToken supply in the market\n     * @return amountCalculated amount of liquidity swapped out / in, depending on whether swap is EXACT_IN / EXACT_OUT\n     * @return protocolFees calculated protocol fees to be charged\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after swap\n     **/\n    function swap(\n        SwapParams calldata swapParams,\n        address sender,\n        uint256 baseTokenSupply\n    ) external payable returns (uint256 amountCalculated, uint128 protocolFees, TokenPrices memory tokenPrices);\n\n    /**\n     * @notice Updates market state (e.g., accrues debt fees and protocol fees)\n     * @dev Calling mint / redeem / swap also updates internal states, but updateState allows a user to update the state without mint / redeem /swapping tokens\n     * @param marketId market to update\n     * @param marketParams marketParams of market to update\n     * @param baseTokenSupply total baseToken supply in the market\n     * @param data additional data to send to LEX\n     * @return protocolFees calculated protocol fees to be charged\n     **/\n    function updateState(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        uint256 baseTokenSupply,\n        bytes calldata data\n    ) external payable returns (uint128 protocolFees);\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Quote functions (do not update internal state)\n\n    /**\n     * @notice calculate Synth tokens to mint given baseLiquidityIn\n     * @notice does not include fees\n     * @param mintParams covenant mint parameters\n     * @param baseTokenSupply total baseToken supply in the market\n     * @param sender sender of tokens coming in\n     * @return aTokenAmountOut amount of aToken to be minted given amountIn\n     * @return zTokenAmountOut amount of zToken to be minted given amountIn\n     * @return protocolFees calculated protocol fees to be charged\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after mint\n     **/\n    function quoteMint(\n        MintParams calldata mintParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (\n            uint256 aTokenAmountOut,\n            uint256 zTokenAmountOut,\n            uint128 protocolFees,\n            uint128 oracleUpdateFee,\n            TokenPrices memory tokenPrices\n        );\n\n    /**\n     * @notice calculates base liquidity out, given synth tokens redeemed\n     * @notice does not include fees\n     * @notice Treats amounts as exact input, and does not check for slippage\n     * @param redeemParams covenant redeem parameters\n     * @param sender sender of tokens coming in\n     * @param baseTokenSupply total baseToken supply in the market\n     * @return baseAmountOut base tokens that would come out\n     * @return protocolFees calculated protocol fees to be charged\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after redeem\n     **/\n    function quoteRedeem(\n        RedeemParams calldata redeemParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (uint256 baseAmountOut, uint128 protocolFees, uint128 oracleUpdateFee, TokenPrices memory tokenPrices);\n    /**\n     * @notice calculates swap between tokens (base or synths)\n     * @notice does not include fees\n     * @dev All parameters are given in raw token decimal encoding.\n     * @param swapParams covenant swap parameters\n     * @param sender sender of tokens coming in\n     * @param baseTokenSupply total baseToken supply in the market\n     * @return amountCalculated amount of liquidity swapped out / in, depending on whether swap is EXACT_IN / EXACT_OUT\n     * @return protocolFees calculated protocol fees to be charged\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices prices of baseToken, aToken and zToken (in quote tokens) after swap\n     **/\n    function quoteSwap(\n        SwapParams calldata swapParams,\n        address sender,\n        uint256 baseTokenSupply\n    )\n        external\n        view\n        returns (\n            uint256 amountCalculated,\n            uint128 protocolFees,\n            uint128 oracleUpdateFee,\n            TokenPrices memory tokenPrices\n        );\n}\n"
        },
        "src/interfaces/ISynthToken.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {MarketId, AssetType} from \"../interfaces/ICovenant.sol\";\nimport {IERC20} from \"@openzeppelin/token/ERC20/IERC20.sol\";\n\n/**\n * @title ICovenant\n * @author Amorphous\n * @notice Defines the the core interface of Covenant Liquid markets.\n **/\ninterface ISynthToken is IERC20 {\n    // Notice - gets CovenantCore associated with the SynthToken\n    function getCovenantCore() external returns (address);\n\n    // Notice - gets marketId associated with the SynthToken\n    function getMarketId() external returns (MarketId);\n\n    // Notice - gets synthType associated with the SynthToken\n    function getSynthType() external returns (AssetType);\n\n    /**\n     * @dev Expose share mint functionality to Covenant Liquid\n     */\n    function lexMint(address account, uint256 value) external;\n\n    /**\n     * @dev Expose share redeem functionality to Covenant Liquid\n     */\n    function lexBurn(address account, uint256 value) external;\n}\n"
        },
        "src/interfaces/IPriceOracle.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\n/**\n * @title IPriceOracle\n * @author Covenant Labs\n * @notice Defines the the core interface for Covenant oracles.\n * @notice Extends the oracle interface of Euler Labs, https://github.com/euler-xyz/euler-price-oracle/\n    to include pricePreviews and priceUpdates/getUpdateFee for pull oracles\n * @notice All functions return a value.  if bid/ask price not implemented, then getQuotes returns bid = ask = getQuote()\n **/\n\ninterface IPriceOracle {\n    /// @notice Get the name of the oracle.\n    /// @return The name of the oracle.\n    function name() external view returns (string memory);\n\n    /// @notice One-sided price: How much quote token you would get for inAmount of base token, assuming no price spread.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @return outAmount The amount of `quote` that is equivalent to `inAmount` of `base`.\n    function getQuote(uint256 inAmount, address base, address quote) external view returns (uint256 outAmount);\n\n    /// @notice Two-sided price: How much quote token you would get/spend for selling/buying inAmount of base token.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @return bidOutAmount The amount of `quote` you would get for selling `inAmount` of `base`.\n    /// @return askOutAmount The amount of `quote` you would spend for buying `inAmount` of `base`.\n    function getQuotes(\n        uint256 inAmount,\n        address base,\n        address quote\n    ) external view returns (uint256 bidOutAmount, uint256 askOutAmount);\n\n    /// @notice priceUpdate for pulled pricing (e.g., Pyth, Redstone, Chainlink datastreams)\n    /// @notice allows pushing pricing to be verified on-chain. Function is payable to receive required payment.\n    /// @param base The token that is being priced (use here for routing purposes).\n    /// @param quote The token that is the unit of account (use here for routing purposes).\n    /// @param updateData Update data package (contains price and other info to be verified onchain)\n    function updatePriceFeeds(address base, address quote, bytes calldata updateData) external payable;\n\n    /// @notice Returns the required fee to update an oracle price.\n    /// @param base The token that is being priced (use here for routing purposes).\n    /// @param quote The token that is the unit of account (use here for routing purposes).\n    /// @param updateData Array of price update data.\n    /// @return updateFee The required fee in Wei.\n    function getUpdateFee(\n        address base,\n        address quote,\n        bytes calldata updateData\n    ) external view returns (uint128 updateFee);\n\n    /// @notice Preview of getQuote, with a longer lookback window to avoid quote blocking\n    /// @notice One-sided price: How much quote token you would get for inAmount of base token, assuming no price spread.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @return outAmount The amount of `quote` that is equivalent to `inAmount` of `base`.\n    function previewGetQuote(uint256 inAmount, address base, address quote) external view returns (uint256 outAmount);\n\n    /// @notice Preview of getQuotes, with a longer lookback window to avoid quote blocking\n    /// @notice Two-sided price: How much quote token you would get/spend for selling/buying inAmount of base token.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @return bidOutAmount The amount of `quote` you would get for selling `inAmount` of `base`.\n    /// @return askOutAmount The amount of `quote` you would spend for buying `inAmount` of `base`.\n    function previewGetQuotes(\n        uint256 inAmount,\n        address base,\n        address quote\n    ) external view returns (uint256 bidOutAmount, uint256 askOutAmount);\n}\n"
        },
        "src/lex/latentswap/interfaces/ITokenData.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\n/**\n * @title ITokenData\n * @author Covenant Labs\n * @notice Defines interface for symbol and decimal overrides\n **/\n\ninterface ITokenData {\n    function assetDecimals(address asset) external view returns (uint8);\n    function assetSymbol(address asset) external view returns (string memory);\n    function assetName(address asset) external view returns (string memory);\n}\n"
        },
        "src/lex/latentswap/libraries/TokenData.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {SafeMetadata, IERC20} from \"../../../libraries/SafeMetadata.sol\";\nimport {ITokenData} from \"../interfaces/ITokenData.sol\";\n\n/// @title TokenData\n/// @author Covenant Labs\n/// @notice sets symbol, decimals and name overrides for a token\n/// @dev each item can be set independently, and will override existing ERC20 values for the respecitve token\n/// @dev if both symbol and decimals are overriden, a quote token need not be an actual ERC20\n/// @dev this gives the flexibility to use currency ISO addresses and symbols for quote tokens.\n/// @dev Oracles can use ERC-7535, ISO 4217 or other conventions to represent non-ERC20 assets as addresses.\n/// @dev e.g., EIP7528 would set address = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\", symbol = \"ETH\", decimals = 18.\nabstract contract TokenData is ITokenData {\n    using SafeMetadata for IERC20;\n\n    // mapping of decimal overrides for specific assets\n    mapping(address => uint8) _decimals;\n\n    // mapping of symbol overrides for specific assets\n    mapping(address => string) _symbol;\n\n    // mapping of name overrides for specific assets\n    mapping(address => string) _name;\n\n    error TokenData_InvalidDecimals();\n\n    event SetTokenDecimals(address indexed token, uint8 oldDecimals, uint8 newDecimals);\n    event SetTokenSymbol(address indexed token, string oldSymbol, string newSymbol);\n    event SetTokenName(address indexed token, string oldName, string newName);\n\n    function assetDecimals(address asset) public view returns (uint8 decimals_) {\n        return _assetDecimals(asset);\n    }\n\n    function assetSymbol(address asset) public view returns (string memory symbol_) {\n        return _assetSymbol(asset);\n    }\n\n    function assetName(address asset) public view returns (string memory name_) {\n        return _assetName(asset);\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n\n    // @dev - Stored decimals are an override.\n    // if stored decimals is 0, try and get ERC20 decimals\n    function _assetDecimals(address asset) internal view returns (uint8 decimals_) {\n        decimals_ = _decimals[asset]; //check if there is an override for this asset\n        if (decimals_ > 0) return decimals_;\n        else {\n            // try and read from asset itself\n            bool success;\n            (success, decimals_) = IERC20(asset).tryGetDecimals();\n            return success ? decimals_ : 18;\n        }\n    }\n\n    // @dev - Stored symbol are an override.\n    // @dev - if stored symbol is \"\", try and get ERC20 symbol\n    function _assetSymbol(address asset) internal view returns (string memory symbol_) {\n        symbol_ = _symbol[asset]; //check if there is an override for this asset\n        if (bytes(symbol_).length > 0) return symbol_;\n        else {\n            // try and read from asset itself\n            bool success;\n            (success, symbol_) = IERC20(asset).tryGetSymbol();\n            return success ? symbol_ : \"\";\n        }\n    }\n\n    // @dev - Stored name are an override.\n    // @dev - if stored name is \"\", try and get ERC20 name\n    function _assetName(address asset) internal view returns (string memory name_) {\n        name_ = _name[asset]; //check if there is an override for this asset\n        if (bytes(name_).length > 0) return name_;\n        else {\n            // try and read from asset itself\n            bool success;\n            (success, name_) = IERC20(asset).tryGetName();\n            return success ? name_ : \"\";\n        }\n    }\n\n    // internal functions.  These should be exposed with the appropriate access modifiers\n    // @dev - if newDecimals = 0, then _assetDecimals will try and get ERC20 decimals\n    function _updateAssetDecimals(address asset, uint8 newDecimals) internal {\n        if (newDecimals > 18) revert TokenData_InvalidDecimals();\n        uint8 oldDecimals = _assetDecimals(asset); // get old decimals\n        _decimals[asset] = newDecimals;\n        emit SetTokenDecimals(asset, oldDecimals, newDecimals);\n    }\n\n    // internal functions.  These should be exposed with the appropriate access modifiers\n    // @dev - if newSymbol = \"\", then _assetSymbol will try and get ERC20 symbol\n    function _updateAssetSymbol(address asset, string calldata newSymbol) internal {\n        string memory oldSymbol = _assetSymbol(asset); // get old symbol\n        _symbol[asset] = newSymbol;\n        emit SetTokenSymbol(asset, oldSymbol, newSymbol);\n    }\n\n    // internal functions.  These should be exposed with the appropriate access modifiers\n    // @dev - if newName = \"\", then _assetNAme will try and get ERC20 name\n    function _updateAssetName(address asset, string calldata newName) internal {\n        string memory oldName = _assetName(asset); // get old symbol\n        _name[asset] = newName;\n        emit SetTokenName(asset, oldName, newName);\n    }\n}\n"
        },
        "src/lex/latentswap/libraries/FixedPoint.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint {\n    // Q96 Fixed Point Constants\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n    uint256 internal constant Q160 = 0x0010000000000000000000000000000000000000000;\n    uint256 internal constant Q192 = 0x1000000000000000000000000000000000000000000000000;\n\n    // WAD Fixed Point Constants\n    uint8 internal constant RESOLUTION_WAD = 18;\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    // RAY Fixed Point Constants\n    uint8 internal constant RESOLUTION_RAY = 27;\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    // Perecentage Math Constants\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n}\n"
        },
        "src/lex/latentswap/libraries/LSErrors.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.30;\n\nlibrary LSErrors {\n    error E_LEX_OnlyCovenantCanCall(); // 0x1150f470\n    error E_LEX_ZeroAddress(); // 0xad5292ae\n    error E_LEX_ZeroLiquidity(); // 0xb38d3cff\n    error E_LEX_AlreadyInitialized(); // 0xbb304191\n    error E_LEX_IncorrectInitializationPrice(); // 0xc868f36a\n    error E_LEX_IncorrectInitializationLnRateBias(); // 0x4cf570ef\n    error E_LEX_InsufficientTokens(); // 0x6cf03401\n    error E_LEX_ActionNotAllowedGivenLTVlimit(); // 0x2ab66638\n    error E_LEX_ActionNotAllowedUnderCollateralized(); // 0xabc1fa28\n    error E_LEX_OperationNotAllowed(); // 0x82a547cd\n    error E_LEX_RedeemCapExceeded(); // 0xef9b092a\n    error E_LEX_MintCapExceeded(); // 0x6c8de6e1\n    error E_LEX_OraclePriceTooLowForMarket(); // 0x417969ec\n    error E_LEX_IncorrectInitializationDuration(); // 0x50560b48\n    error E_LEX_BaseAssetNotERC20(); // 0x77e6fe18\n    error E_LEX_QuoteAssetHasNoSymbol(); // 0xd5862a35\n    error E_LEX_MarketDoesNotExist(); // 0xda47482e\n    error E_LEX_Overdeposit(); // 0x94f85219\n    error E_LEX_InsufficientAmount(); // 0xe869f1da\n    error E_LEX_MarketSizeLimitExceeded(); // 0x23565a11\n}\n"
        },
        "src/lex/latentswap/libraries/LatentSwapLogic.sol": {
            "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {TokenPrices, AssetType} from \"../../../interfaces/ILiquidExchangeModel.sol\";\nimport {LexConfig, LexState, MintParams, RedeemParams, SwapParams, MarketId, MarketParams, LexParams} from \"../interfaces/ILatentSwapLEX.sol\";\nimport {Math} from \"@openzeppelin/utils/math/Math.sol\";\nimport {LSErrors} from \"./LSErrors.sol\";\nimport {LatentMath} from \"./LatentMath.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\nimport {DebtMath} from \"./DebtMath.sol\";\nimport {UtilsLib} from \"../../../libraries/Utils.sol\";\nimport {PercentageMath} from \"@aave/libraries/math/PercentageMath.sol\";\nimport {SaturatingMath} from \"./SaturatingMath.sol\";\nimport {IPriceOracle} from \"../../../interfaces/IPriceOracle.sol\";\nimport {IERC20} from \"@openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/utils/math/SafeCast.sol\";\nimport {SafeMetadata} from \"../../../libraries/SafeMetadata.sol\";\nimport {Strings} from \"@openzeppelin/utils/Strings.sol\";\nimport {FixedPointMathLib} from \"@solady/utils/FixedPointMathLib.sol\";\n\n/**\n * @title Latent Swap Logic\n * @author Covenant Labs\n **/\n\nlibrary LatentSwapLogic {\n    using SafeCast for uint256;\n    using SafeCast for bool;\n    using Math for uint256;\n    using SaturatingMath for uint256;\n    using PercentageMath for uint256;\n    using SafeMetadata for IERC20;\n\n    uint8 constant MAX_MINT_FACTOR_CAP = 1; // x1 max liquidity mint as a % of total market liquidity (measured through ETWAP). ie, limits amount that can be minted in ETWAP_MIN_HALF_LIFE minutes\n    uint8 constant MAX_REDEEM_FACTOR_CAP = 2; // 1/4 max liquidity burn as a % of total market liquidity (measured through ETWAP). ie, limits amount that can be burned in ETWAP_MIN_HALF_LIFE minutes\n    uint256 constant MAX_SYNTH_MINT_CAP = uint256(1) << 242; // do not allow minting more than 2^242 in aTokens and zTokens.  This allows for further market appreciation in value (and protects from percentageMul overflows)\n    uint16 constant ETWAP_MIN_HALF_LIFE = 30 minutes; // Minimum half life of ETWAP calculations (ETWAP can have a longer halflife if market has infrequent updates)\n    uint96 constant LN2 = 693147180559945331; // ln(2) in WADs.  Used for half-life calculations\n    uint32 constant MIN_LIQRATIOX96 = 1e9; // Minimum Price * LiqRatio for market.  Prices under 1 wei (if in WADs) will revert.\n    uint40 constant NEG_WORKOUT_LN_RATE = 116323331638; // -1% daily workout rate (when undercollateralized or above MAX_LIMIT_LTV). Expressed as lnRate per second in WADs.  Workout rate is negative, but here expressed as positive.\n    uint8 constant DEBT = 0; // used for indexing into supplyAmounts and dexAmounts\n    uint8 constant LVRG = 1; // used for indexing into supplyAmounts and dexAmounts\n\n    // Market state - for cache + state calculated values\n    struct LexFullState {\n        LexState lexState;\n        LexConfig lexConfig;\n        uint256 baseTokenSupply;\n        uint256[2] supplyAmounts;\n        uint256[2] dexAmounts;\n        uint256[3] dexAmountsScaled;\n        uint256[3] synthAmountsScaled;\n        uint256 liquidityRatioX96;\n        uint160 liquidity;\n        uint96 accruedProtocolFee;\n        bool underCollateralized;\n    }\n\n    // Market init info struct\n    struct MarketInitInfo {\n        string baseName;\n        string baseSymbol;\n        string quoteSymbol;\n        string aTokenName;\n        string aTokenSymbol;\n        string zTokenName;\n        string zTokenSymbol;\n        uint8 synthDecimals;\n        uint8 quoteDecimals;\n        uint8 noCapLimit;\n        string levStr;\n        string durStr;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // External library functions\n    ///////////////////////////////////////////////////////////////////////////////\n\n    function mintLogic(\n        MintParams calldata mintParams,\n        LexParams memory lexParams,\n        LexConfig storage lexConfig,\n        LexState storage lexState,\n        uint256 baseTokenSupply,\n        bool isPreview\n    )\n        external\n        view\n        returns (\n            LexFullState memory currentState,\n            TokenPrices memory tokenPrices,\n            uint256 aTokenAmountOut,\n            uint256 zTokenAmountOut\n        )\n    {\n        ///////////////////////////////\n        // Calculate market state (storage read)\n        currentState = _calculateMarketState(\n            mintParams.marketParams,\n            lexParams,\n            lexConfig,\n            lexState,\n            baseTokenSupply,\n            isPreview\n        );\n\n        ///////////////////////////////\n        // Calculate mint\n        (aTokenAmountOut, zTokenAmountOut) = _calcMint(lexParams, currentState, mintParams.baseAmountIn);\n\n        /////////////////////////////////////\n        // Calculate token prices (post action)\n        tokenPrices = _calculateTokenPrices(lexParams, currentState);\n    }\n\n    function redeemLogic(\n        RedeemParams calldata redeemParams,\n        LexParams memory lexParams,\n        LexConfig storage lexConfig,\n        LexState storage lexState,\n        uint256 baseTokenSupply,\n        bool isPreview\n    ) external view returns (LexFullState memory currentState, TokenPrices memory tokenPrices, uint256 amountOut) {\n        ///////////////////////////////\n        // Calculate market state (storage read)\n        currentState = _calculateMarketState(\n            redeemParams.marketParams,\n            lexParams,\n            lexConfig,\n            lexState,\n            baseTokenSupply,\n            isPreview\n        );\n\n        ///////////////////////////////\n        // Calculate redeem\n        (amountOut, currentState.lexState.lastSqrtPriceX96) = _calcRedeem(\n            lexParams,\n            currentState,\n            redeemParams.aTokenAmountIn,\n            redeemParams.zTokenAmountIn\n        );\n\n        /////////////////////////////////////\n        // Calculate token prices (post action)\n        // @dev - prices are miscalculated if a market is fully redeemed, and are stated pre-action instead.\n        tokenPrices = _calculateTokenPrices(lexParams, currentState);\n    }\n\n    function swapLogic(\n        SwapParams calldata swapParams,\n        LexParams memory lexParams,\n        LexConfig storage lexConfig,\n        LexState storage lexState,\n        uint256 baseTokenSupply,\n        bool isPreview\n    )\n        external\n        view\n        returns (LexFullState memory currentState, TokenPrices memory tokenPrices, uint256 amountCalculated)\n    {\n        ///////////////////////////////\n        // Calculate market state (storage read)\n        currentState = _calculateMarketState(\n            swapParams.marketParams,\n            lexParams,\n            lexConfig,\n            lexState,\n            baseTokenSupply,\n            isPreview\n        ); ///////////////////////////////\n\n        // Calculate swap\n        (amountCalculated, currentState.lexState.lastSqrtPriceX96) = _calcSwap(\n            lexParams,\n            currentState,\n            swapParams.amountSpecified,\n            swapParams.assetIn,\n            swapParams.assetOut,\n            swapParams.isExactIn\n        );\n\n        /////////////////////////////////////\n        // Calculate token prices (post action)\n        // @dev - prices are miscalculated if a market is fully redeemed, and are stated pre-action instead.\n        tokenPrices = _calculateTokenPrices(lexParams, currentState);\n    }\n\n    // Retrieve baseToken price\n    // @dev - baseTokenPrice is the value of 10^18 baseTokens, in quoteTokens, irrespective of actual # of decimal precision the baseToken has\n    function readBasePriceAndCalculateLiqRatio(\n        MarketParams calldata marketParams,\n        uint256 liquidityConcentrationX96,\n        int8 scaleDecimals,\n        bool isPreview\n    ) external view returns (uint256 price, uint256 liqRatioX96) {\n        return _readBasePriceAndCalculateLiqRatio(marketParams, liquidityConcentrationX96, scaleDecimals, isPreview);\n    }\n\n    function calculateMarketState(\n        MarketParams calldata marketParams,\n        LexParams memory lexParams,\n        LexConfig storage lexConfig,\n        LexState storage lexState,\n        uint256 baseTokenSupply,\n        bool isPreview\n    ) external view returns (LexFullState memory marketState) {\n        return _calculateMarketState(marketParams, lexParams, lexConfig, lexState, baseTokenSupply, isPreview);\n    }\n\n    function calcRatio(\n        LexParams memory lexParams,\n        LexFullState memory marketState,\n        AssetType base,\n        AssetType quote\n    ) external pure returns (uint256 price) {\n        return _calcRatio(lexParams, marketState, base, quote);\n    }\n\n    function getDebtPriceDiscount(\n        uint160 edgeSqrtPriceX96_A,\n        uint160 edgeSqrtPriceX96_B,\n        uint160 currentSqrtPriceX96,\n        uint256 target_dXdL_X96\n    ) external pure returns (uint256 currentPriceDiscount) {\n        return _getDebtPriceDiscount(edgeSqrtPriceX96_A, edgeSqrtPriceX96_B, currentSqrtPriceX96, target_dXdL_X96);\n    }\n\n    // @dev - externalizing computations used during LatentSwapLEX contract creation\n    function computeMaxLTVandTargetdXdL(\n        uint160 edgeSqrtPriceX96_A,\n        uint160 edgeSqrtPriceX96_B,\n        uint160 limMaxSqrtPriceX96\n    ) external pure returns (uint256 maxLTV, uint256 target_dXdL_X96) {\n        maxLTV = LatentMath.computeLTV(edgeSqrtPriceX96_A, edgeSqrtPriceX96_B, limMaxSqrtPriceX96);\n        target_dXdL_X96 = LatentMath.targetXvsL(edgeSqrtPriceX96_A, edgeSqrtPriceX96_B);\n    }\n\n    // @dev - externalizing computations used during market initialization\n    function getInitMarketInfo(\n        MarketParams calldata marketParams,\n        uint256 debtDuration,\n        uint160 edgeSqrtPriceX96_A,\n        uint160 edgeSqrtPriceX96_B,\n        uint8 baseTokenNoCapLimit,\n        uint8 quoteDecimals,\n        string memory quoteSymbol\n    ) external view returns (MarketInitInfo memory info) {\n        bool success;\n\n        // Get base asset name and symbol (cannot be overriden)\n        (success, info.baseName) = IERC20(marketParams.baseToken).tryGetName();\n        if (!success) revert LSErrors.E_LEX_BaseAssetNotERC20();\n        (success, info.baseSymbol) = IERC20(marketParams.baseToken).tryGetSymbol();\n        if (!success) revert LSErrors.E_LEX_BaseAssetNotERC20();\n\n        // Get quote symbol with overrides\n        info.quoteSymbol = quoteSymbol; // read\n        if (bytes(info.quoteSymbol).length == 0) revert LSErrors.E_LEX_QuoteAssetHasNoSymbol();\n\n        // Get synthDecimals decimals (== quote decimals with overrides)\n        info.synthDecimals = quoteDecimals;\n        if (info.synthDecimals == 0) info.synthDecimals = 18;\n\n        // Get actual quote decimals (as would be returned by IPriceOracle)\n        (success, info.quoteDecimals) = IERC20(marketParams.quoteToken).tryGetDecimals();\n        if (!success) info.quoteDecimals = 18;\n\n        // Get base Token noCap decimals\n        info.noCapLimit = baseTokenNoCapLimit;\n        if (info.noCapLimit == 0) {\n            // default threshold above which mint / redeem cap are applied is equivalent to ~1 baseToken\n            (bool success2, uint8 baseDecimals) = IERC20(marketParams.baseToken).tryGetDecimals();\n            if (!success2)\n                info.noCapLimit = uint8(60); // 18 Decimals -> 60 noCapLimit\n            else info.noCapLimit = (FixedPointMathLib.log2(10 ** baseDecimals) + 1).toUint8();\n        }\n\n        // Calculate target leverage\n        // leverage factor = 1/(1-targetLTV).  e.g., 50% -> 2, 80% -> 5, 90% -> 10, 95% -> 20\n        info.levStr = Strings.toString(\n            (FixedPoint.PERCENTAGE_FACTOR + 1) /\n                (FixedPoint.PERCENTAGE_FACTOR -\n                    LatentMath.computeLTV(edgeSqrtPriceX96_A, edgeSqrtPriceX96_B, uint160(FixedPoint.Q96)))\n        );\n\n        // Calculate duration in months / years\n        // e.g., 1M, 3M, 6M, 1Y, 2Y, 5Y\n        // @dev - simplified approach rounds down.\n        uint256 months = debtDuration / (30 days);\n        if (months < 12) info.durStr = string.concat(Strings.toString(months), \"M\");\n        else info.durStr = string.concat(Strings.toString(debtDuration / (365 days)), \"Y\");\n\n        info.aTokenName = string.concat(info.baseName,\" x\",info.levStr,\" Leverage Coin (\",info.quoteSymbol,\"/\",info.durStr,\")\"); // prettier-ignore\n        info.aTokenSymbol = string.concat(info.baseSymbol, \"x\", info.levStr, \".\", info.quoteSymbol);\n        info.zTokenName = string.concat(info.quoteSymbol,\" Yield Coin - backed by \",info.baseSymbol,\" (x\",info.levStr,\"/\",info.durStr,\")\"); // prettier-ignore\n        info.zTokenSymbol = string.concat(info.quoteSymbol, \".b.\", info.baseSymbol);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Internal functions\n    ///////////////////////////////////////////////////////////////////////////////\n\n    function _calcMint(\n        LexParams memory lexParams,\n        LexFullState memory marketState,\n        uint256 baseTokenAmountIn\n    ) internal pure returns (uint256 aTokenAmountOut, uint256 zTokenAmountOut) {\n        ///////////////////////////////\n        // Validate inputs\n\n        // Check if undercollateralized (reverts if so)\n        _checkUnderCollateralized(marketState);\n\n        // Check LTV before mint (reverts if LTV above MAX_LIMIT_LTV)\n        // @dev - minting aTokens when above MAX_LIMIT_LTV is blocked to avoid excessive aToken dilution\n        // in high LTV or undercollateralized markets.\n        _checkLTV(marketState.lexState.lastSqrtPriceX96, lexParams.limMaxSqrtPriceX96);\n\n        // Check if mint amount is too large given market size\n        _checkMintCap(\n            marketState.baseTokenSupply,\n            marketState.lexState.lastETWAPBaseSupply,\n            baseTokenAmountIn,\n            marketState.lexConfig.noCapLimit\n        );\n\n        ///////////////////////////////\n        // Calculate mint\n        // Calculate liquidity coming in (round down)\n        uint160 liquidityIn = _synthToDex(marketState, baseTokenAmountIn, AssetType.BASE, Math.Rounding.Floor)\n            .toUint160();\n        // Calculate dex amounts that should be minted\n\n        (uint256 zDexToMint, uint256 aDexToMint) = LatentMath.computeMint(\n            marketState.lexState.lastSqrtPriceX96,\n            lexParams.edgeSqrtPriceX96_A,\n            lexParams.edgeSqrtPriceX96_B,\n            liquidityIn\n        );\n\n        // Calculate actual zTokens / aTokens to mint (round down).\n        // @dev - Use debt ratio for leverage token if this is the first liquidity in\n        // (ratio not important for leverage token, so keep in targetLTV range)\n        zTokenAmountOut = _dexToSynth(marketState, zDexToMint, AssetType.DEBT, Math.Rounding.Floor);\n        aTokenAmountOut = _dexToSynth(marketState, aDexToMint, AssetType.LEVERAGE, Math.Rounding.Floor);\n\n        ///////////////////////////////\n        // Validate outputs\n\n        // ensure we are not miniting more than MAX_SYNTH_MINT_CAP for zToken and aToken\n        // Block minting while still allowing market value to appreciate.\n        _checkSynthMintCap(marketState.supplyAmounts[DEBT], zTokenAmountOut);\n        _checkSynthMintCap(marketState.supplyAmounts[LVRG], aTokenAmountOut);\n\n        ///////////////////////////////\n        // Charge fee by reducing out amount\n        if (lexParams.swapFee > 0) {\n            zTokenAmountOut = zTokenAmountOut.percentMul(FixedPoint.PERCENTAGE_FACTOR - lexParams.swapFee);\n            aTokenAmountOut = aTokenAmountOut.percentMul(FixedPoint.PERCENTAGE_FACTOR - lexParams.swapFee);\n        }\n    }\n\n    function _calcRedeem(\n        LexParams memory lexParams,\n        LexFullState memory marketState,\n        uint256 aTokenAmountIn,\n        uint256 zTokenAmountIn\n    ) internal pure returns (uint256 amountOut, uint160 nextSqrtPriceX96) {\n        // store for output validation\n        uint160 beforeSqrtPriceX96 = marketState.lexState.lastSqrtPriceX96;\n\n        ///////////////////////////////\n        // Validate inputs\n        if (aTokenAmountIn > marketState.supplyAmounts[LVRG]) revert LSErrors.E_LEX_InsufficientTokens();\n        if (zTokenAmountIn > marketState.supplyAmounts[DEBT]) revert LSErrors.E_LEX_InsufficientTokens();\n\n        // Validate liquidity\n        // @dev - testing baseTokenSupply, because logic below allows for removal of baseTokenSupply\n        // even if the market's calculated liquidity = 0.  In these situations, we do not go through\n        // the latentSwap invariant, but instead assume all baseTokens belong to zToken holders (if any),\n        // or otherwise to aToken holders, and redeem actionas are done proportioanl to holdings.\n        if (marketState.baseTokenSupply == 0) revert LSErrors.E_LEX_ZeroLiquidity();\n\n        ///////////////////////////////\n        // Calculate redeem\n\n        // Check for a full redeem\n        if (aTokenAmountIn == marketState.supplyAmounts[LVRG] && zTokenAmountIn == marketState.supplyAmounts[DEBT]) {\n            // @dev - when full redeem, no swap fee nor redeemCap checks, set to target price\n            // @dev - we acknowledge that there is a footgun risk or someone preemptin a full redeem to capture fees\n            // ie, redeem fees would not be captured by the attacker.  This can be mitigated by redeeming in two steps if\n            // the last user feels the fees are worth it...\n            // @dev - it is possible to redeem dust baseToken amounts even when liquidity == 0\n            amountOut = marketState.baseTokenSupply;\n            nextSqrtPriceX96 = uint160(FixedPoint.Q96);\n        } else {\n            if (marketState.underCollateralized || marketState.liquidity == 0) {\n                if (marketState.supplyAmounts[DEBT] > 0) {\n                    // if market is undercollateralized, only allow zToken -> base redeems, and make these proportional\n                    // @dev - it is possible to redeem undercollateralized markets even if baseSupply > 0 but liquidity == 0\n                    if (aTokenAmountIn > 0) revert LSErrors.E_LEX_ActionNotAllowedUnderCollateralized();\n\n                    // Proportional redeem\n                    // @dev - we do not go through the _synthToDex -> LatentMath -> _dexToSynth pathway\n                    // to calculate amounts given we are at the market extreme where debt tokens are the full owners of base tokens\n                    // and amounts can be just calculated proportional to market amounts\n                    // @notice - amount out is a floor, but we can do a full redeem if zTokenAmountIn == marketState.supplyAmounts[DEBT]\n                    amountOut = marketState.baseTokenSupply.mulDiv(zTokenAmountIn, marketState.supplyAmounts[DEBT]);\n\n                    // Calc next price across the following three states:\n                    // 1 - zTokens still in market, so remains undercollateralized and nextSqrtPrice = edgeSqrtPriceX96_B\n                    // 1 - No baseTokens or zTokens left, but aTokens still in market -> nextSqrtPrice = edgeSqrtPriceX96_A\n                    // 2 - fully empy market -> nextSqrtPrice = 1\n                    nextSqrtPriceX96 = (amountOut < marketState.baseTokenSupply)\n                        ? lexParams.edgeSqrtPriceX96_B\n                        : (marketState.supplyAmounts[LVRG] > 0)\n                            ? lexParams.edgeSqrtPriceX96_A\n                            : uint160(FixedPoint.Q96);\n                } else {\n                    ////////////////////////////////////\n                    // Allow proprional redeeming of baseTokens with leverage tokens, given no zTokens in the market\n                    amountOut = marketState.baseTokenSupply.mulDiv(aTokenAmountIn, marketState.supplyAmounts[LVRG]);\n                    nextSqrtPriceX96 = (amountOut < marketState.baseTokenSupply)\n                        ? lexParams.edgeSqrtPriceX96_A\n                        : uint160(FixedPoint.Q96);\n                }\n                // No redeem fees charged in undercollateralized or  zero liquiditymarket\n\n                ///////////////////////////////////////\n                // Validate output\n                // Check if redeem amount is too large given market size, even when undercollateralized\n                _checkRedeemCap(\n                    marketState.baseTokenSupply,\n                    marketState.lexState.lastETWAPBaseSupply,\n                    amountOut,\n                    marketState.lexConfig.noCapLimit\n                );\n            } else {\n                uint256 zTokenDexIn = _synthToDex(marketState, zTokenAmountIn, AssetType.DEBT, Math.Rounding.Floor);\n                uint256 aTokenDexIn = _synthToDex(marketState, aTokenAmountIn, AssetType.LEVERAGE, Math.Rounding.Floor);\n\n                // Calculate liquidity out given tokens in\n                uint160 liquidityOut;\n                (liquidityOut, nextSqrtPriceX96) = LatentMath.computeRedeem(\n                    marketState.liquidity,\n                    marketState.lexState.lastSqrtPriceX96,\n                    lexParams.edgeSqrtPriceX96_A,\n                    lexParams.edgeSqrtPriceX96_B,\n                    zTokenDexIn,\n                    aTokenDexIn\n                );\n\n                // Calculate baseToken amount out given liquidity out\n                // Round down amount out\n                amountOut = _dexToSynth(marketState, liquidityOut, AssetType.BASE, Math.Rounding.Floor);\n\n                if (amountOut >= marketState.baseTokenSupply || liquidityOut >= marketState.liquidity) {\n                    // @dev - this is close to a full redeem, but there is some aToken or zToken dust left in the market\n                    // @dev - when full redeem, no swap fee nor redeemCap checks, set to target price\n                    // @dev - we acknowledge that there is a footgun risk or someone preemptin a full redeem to capture fees\n                    // ie, redeem fees would not be captured by the attacker.  This can be mitigated by redeeming in two steps if\n                    // the last user feels the fees are worth it...\n                    // @dev - it is possible to redeem dust baseToken amounts even when liquidity == 0\n                    // @dev - some dust aTokens or zTokens might be left in the market (valueless).\n                    // @dev - We ackownolded that it could be argued that fees should not be skipped in this case.\n                    // If we charged fees, a majority holder could redeeming here in various steps to avoid paying dust holders\n                    // We acknowledge this fact by just not charging fees in this scenario when only dust holders are left.\n                    amountOut = marketState.baseTokenSupply;\n                    nextSqrtPriceX96 = uint160(FixedPoint.Q96);\n                } else {\n                    ///////////////////////////////////////\n                    // Validate output\n                    // Check if redeem amount is too large given market size\n                    _checkRedeemCap(\n                        marketState.baseTokenSupply,\n                        marketState.lexState.lastETWAPBaseSupply,\n                        amountOut,\n                        marketState.lexConfig.noCapLimit\n                    );\n\n                    ////////////////////////////////////////\n                    // Charge fee by reducing out amount (after checkRedeemCap)\n                    if (lexParams.swapFee > 0)\n                        amountOut = amountOut.percentMul(FixedPoint.PERCENTAGE_FACTOR - lexParams.swapFee);\n                }\n            }\n        }\n\n        // Additional validate outputs\n\n        // Allow redeems that lower LTV (lower DEX price) or keep as is, and otherwise\n        // check whether action pushes LTV past High limit (reverts if so)\n        if (nextSqrtPriceX96 > beforeSqrtPriceX96) _checkLTV(nextSqrtPriceX96, lexParams.limHighSqrtPriceX96);\n\n        // @dev - allow redeeming 0 base tokens (as a way to remove dust in markets if need be)\n    }\n\n    struct calcSwapVars {\n        uint256 inputDexAmount;\n        uint256 calcDexAmount;\n        uint256 aDexTokenAmount;\n        uint256 zDexTokenAmount;\n        uint256 newDexTokenAmount;\n        uint160 liquidityNew;\n        AssetType fixedSynth;\n    }\n\n    function _calcSwap(\n        LexParams memory lexParams,\n        LexFullState memory marketState,\n        uint256 swapAmount,\n        AssetType assetIn,\n        AssetType assetOut,\n        bool isExactIn\n    ) internal pure returns (uint256 calcAmount, uint160 nextSqrtPriceX96) {\n        ///////////////////////////////\n        // Validate inputs\n        require(assetIn != assetOut);\n\n        // check market liquidity\n        // @dev - it can happen that the market has liquidity == 0, even if baseTokenSupply > 0 and aTokens or zTokens > 0.\n        // However, the market is not operational (more liquidity needs to be added)\n        if (marketState.liquidity == 0) revert LSErrors.E_LEX_ZeroLiquidity();\n\n        // Undercollateralized checks\n        // If undercollateralized, only allow zToken to baseToken swaps  (ie redeem zTokens only)\n        if ((assetIn != AssetType.DEBT) || (assetOut != AssetType.BASE)) _checkUnderCollateralized(marketState);\n\n        // Do not allow buying aTokens if market above MAX_LIMIT_LTV\n        // @dev - markets above MAX_LIMIT_LTV return to a lower LTV through negative funding (zTokens paying aTokens), collateral price appreciation, or zToken -> base swaps\n        if (assetOut == AssetType.LEVERAGE)\n            _checkLTV(marketState.lexState.lastSqrtPriceX96, lexParams.limMaxSqrtPriceX96);\n\n        ///////////////////////////////\n        // Calculate swap\n\n        calcSwapVars memory vars;\n\n        if ((assetIn != AssetType.BASE) && (assetOut != AssetType.BASE)) {\n            // case1: synth for synth swap\n            vars.fixedSynth = isExactIn ? assetIn : assetOut;\n            vars.inputDexAmount = _synthToDex(\n                marketState,\n                swapAmount,\n                vars.fixedSynth,\n                isExactIn ? Math.Rounding.Floor : Math.Rounding.Ceil\n            );\n\n            (vars.calcDexAmount, nextSqrtPriceX96) = LatentMath.computeSwap(\n                marketState.liquidity,\n                marketState.lexState.lastSqrtPriceX96,\n                vars.fixedSynth,\n                vars.inputDexAmount,\n                isExactIn\n            );\n\n            // Convert internal DEX output to synth amounts\n            calcAmount = _dexToSynth(\n                marketState,\n                vars.calcDexAmount,\n                isExactIn ? assetOut : assetIn,\n                isExactIn ? Math.Rounding.Floor : Math.Rounding.Ceil\n            );\n\n            ////////////////////////////////////////////////////////\n            // Validate swap amounts\n            // Do not allow ExactOut > 0 if InputAmount ends being 0\n            if (!isExactIn && calcAmount == 0) revert LSErrors.E_LEX_InsufficientAmount();\n\n            // ensure we are not miniting more than MAX_SYNTH_MINT_CAP for zToken and aToken\n            // Block minting while still allowing market value to appreciate.\n            _checkSynthMintCap(\n                marketState.supplyAmounts[assetOut == AssetType.DEBT ? DEBT : LVRG],\n                isExactIn ? calcAmount : swapAmount\n            );\n        } else if ((assetIn == AssetType.BASE) && isExactIn) {\n            // case2: base token is being swapped with an exact amount in\n\n            // @dev - round down for all conditions\n            vars.liquidityNew = _synthToDex(marketState, swapAmount, AssetType.BASE, Math.Rounding.Floor).toUint160();\n\n            // Mint tokens given liquidity in\n            (vars.zDexTokenAmount, vars.aDexTokenAmount) = LatentMath.computeMint(\n                marketState.lexState.lastSqrtPriceX96,\n                lexParams.edgeSqrtPriceX96_A,\n                lexParams.edgeSqrtPriceX96_B,\n                vars.liquidityNew\n            );\n\n            // update liquidity\n            marketState.liquidity += vars.liquidityNew;\n\n            // swap assetOut\n            (vars.newDexTokenAmount, nextSqrtPriceX96) = LatentMath.computeSwap(\n                marketState.liquidity,\n                marketState.lexState.lastSqrtPriceX96,\n                assetOut == AssetType.DEBT ? AssetType.LEVERAGE : AssetType.DEBT,\n                assetOut == AssetType.DEBT ? vars.aDexTokenAmount : vars.zDexTokenAmount,\n                true\n            );\n\n            // add to swap output the original mint amount of assetOut\n            vars.newDexTokenAmount += Math.ternary(\n                assetOut == AssetType.LEVERAGE,\n                vars.aDexTokenAmount,\n                vars.zDexTokenAmount\n            );\n\n            calcAmount = _dexToSynth(marketState, vars.newDexTokenAmount, assetOut, Math.Rounding.Floor);\n\n            ////////////////////////////////////////////////////////\n            // Validate mintCap if baseToken is being swapped in\n            _checkMintCap(\n                marketState.baseTokenSupply,\n                marketState.lexState.lastETWAPBaseSupply,\n                swapAmount,\n                marketState.lexConfig.noCapLimit\n            );\n\n            ////////////////////////////////////////////////////////\n            // Validate synth mint cap\n            _checkSynthMintCap(marketState.supplyAmounts[assetOut == AssetType.DEBT ? DEBT : LVRG], calcAmount);\n        } else if ((assetOut == AssetType.BASE) && isExactIn) {\n            // case3: base token is being swapped out, with exact synth amount in\n            // @dev - equivalent to redeeming swapAmount of assetIn\n            (calcAmount, nextSqrtPriceX96) = _calcRedeem(\n                lexParams,\n                marketState,\n                (assetIn == AssetType.LEVERAGE) ? swapAmount : 0,\n                (assetIn == AssetType.DEBT) ? swapAmount : 0\n            );\n        } else {\n            revert LSErrors.E_LEX_OperationNotAllowed();\n        }\n\n        // Charge fee by reducing out amount (or increasing in amount)\n        // @dev - Base out swaps were already charged when calling _calcRedeem\n        if (lexParams.swapFee > 0 && (assetOut != AssetType.BASE))\n            calcAmount = isExactIn\n                ? calcAmount.percentMul(FixedPoint.PERCENTAGE_FACTOR - lexParams.swapFee)\n                : calcAmount.percentDiv(FixedPoint.PERCENTAGE_FACTOR - lexParams.swapFee);\n\n        ///////////////////////////////\n        // Additional validate outputs\n\n        // Do not allow actions that increase LTV (and end past High LTV limits)\n        // e.g. aToken sales, or zToken buys if it takes market past High LTV limits\n        // @dev - however, allow actions that make LTV better\n        if (nextSqrtPriceX96 > marketState.lexState.lastSqrtPriceX96)\n            _checkLTV(nextSqrtPriceX96, lexParams.limHighSqrtPriceX96);\n\n        // Validate enough tokens in the market\n        if (\n            (assetIn != AssetType.BASE) &&\n            ((isExactIn ? swapAmount : calcAmount) > marketState.supplyAmounts[(assetIn == AssetType.DEBT) ? 0 : 1])\n        ) revert LSErrors.E_LEX_InsufficientTokens();\n\n        // Validate nextSqrtPriceX96 did not pass lower bound (upper bound already checked above)\n        // @dev - this can happen at the extreme of LTV -> 0% (no debt)\n        if (nextSqrtPriceX96 < lexParams.edgeSqrtPriceX96_A) revert LSErrors.E_LEX_OperationNotAllowed();\n    }\n\n    // /// @dev - returns ratio (price) in WADs\n    function _calcRatio(\n        LexParams memory lexParams,\n        LexFullState memory marketState,\n        AssetType base,\n        AssetType quote\n    ) internal pure returns (uint256 price) {\n        uint256 dexPrice;\n\n        // Calculate price for converting one dex asset to another\n        if (base != AssetType.BASE && quote != AssetType.BASE) {\n            dexPrice = (base == AssetType.DEBT)\n                ? Math.mulDiv(\n                    marketState.lexState.lastSqrtPriceX96 * FixedPoint.WAD,\n                    marketState.lexState.lastSqrtPriceX96,\n                    FixedPoint.Q192\n                )\n                : ((FixedPoint.Q192 * FixedPoint.WAD) / marketState.lexState.lastSqrtPriceX96) /\n                    marketState.lexState.lastSqrtPriceX96;\n        } else {\n            AssetType synthAsset = (base == AssetType.BASE) ? quote : base;\n            // calculates BASE vs Synth price\n            dexPrice = LatentMath.get_XvsL(\n                marketState.lexState.lastSqrtPriceX96,\n                lexParams.edgeSqrtPriceX96_A,\n                lexParams.edgeSqrtPriceX96_B,\n                synthAsset\n            );\n            if (quote == AssetType.BASE) dexPrice = (FixedPoint.WAD << FixedPoint.RESOLUTION) / dexPrice;\n            else dexPrice = (FixedPoint.WAD * dexPrice) / FixedPoint.Q96;\n        }\n\n        // When calculating price between tokens, we must convert from dex prices to synth prices\n        // ie dexToken1 = currentMarketPrice*dexToken0\n        // => Token1amount * dexTokenRatio[LVRG] = currentMarketPrice * Token0amount * dexTokenRatio[DEBT]\n        // => Token1amount / Token0amount = currentMarketPrice * dexTokenRatio[DEBT] / dexTokenRatio[LVRG]\n        price = _dexToSynth(\n            marketState,\n            _synthToDex(marketState, dexPrice, base, Math.Rounding.Ceil),\n            quote,\n            Math.Rounding.Ceil\n        );\n    }\n\n    // Local variables for _calculateMarketState to avoid stack too deep\n    struct CalcMarketStateVars {\n        uint256 elapsedTime;\n        uint256 spotPriceDiscount;\n        int256 spotLnRateBias;\n        uint256 newDebtNotionalPrice;\n        uint16 yieldFee;\n        uint16 tvlFee;\n        uint256 feeX96;\n        uint256 yieldInBaseUnits;\n        uint256 fee;\n        uint256 invUpdateFactor;\n        uint256 maxDebtValue;\n    }\n\n    // calculates current market state given market params, used by all other internal functions\n    function _calculateMarketState(\n        MarketParams calldata marketParams,\n        LexParams memory lexParams,\n        LexConfig storage lexConfig,\n        LexState storage lexState,\n        uint256 baseTokenSupply,\n        bool isPreview\n    ) internal view returns (LexFullState memory marketState) {\n        CalcMarketStateVars memory vars;\n\n        ////////////////////////////////////////////////////////////////////////////////\n        // Read and cache variables\n        marketState.lexState = lexState;\n        marketState.lexConfig = lexConfig;\n        marketState.baseTokenSupply = baseTokenSupply;\n\n        ////////////////////////////////////////////////////////////////////////////////\n        // Read external values\n        // read synth token supplies (external call to trusted protocol)\n        marketState.supplyAmounts[DEBT] = IERC20(marketState.lexConfig.zToken).totalSupply();\n        marketState.supplyAmounts[LVRG] = IERC20(marketState.lexConfig.aToken).totalSupply();\n\n        // get current baseToken market price from oracle and calculate liquidity ratio\n        (marketState.lexState.lastBaseTokenPrice, marketState.liquidityRatioX96) = _readBasePriceAndCalculateLiqRatio(\n            marketParams,\n            lexParams.targetXvsL,\n            marketState.lexConfig.scaleDecimals,\n            isPreview\n        );\n        ////////////////////////////////////////////////////////////////////////////////\n        // Execute time based accruals\n        // update accrued yield + calc fees according to current blocktime + last market prices\n        // update interest if the current block timestamp is greater than the last update timestamp\n        if (block.timestamp > marketState.lexState.lastUpdateTimestamp) {\n            vars.elapsedTime = block.timestamp - marketState.lexState.lastUpdateTimestamp;\n            marketState.lexState.lastUpdateTimestamp = uint96(block.timestamp);\n\n            // get debt price discount given last dex price. This is done on purpose, to accrue interest\n            // based on past values (and time accrued with those values) vs current spot oracle and market values\n            vars.spotPriceDiscount = _getDebtPriceDiscount(\n                lexParams.edgeSqrtPriceX96_A,\n                lexParams.edgeSqrtPriceX96_B,\n                marketState.lexState.lastSqrtPriceX96,\n                lexParams.targetXvsL\n            );\n\n            // if market price > _limMaxSqrtPriceX96 (ie, aToken selling is locked given high LTV)\n            // this means market is undercollateralized or close to undercollateralized.  We thus activate a slowly increasing workout rate.\n            // which creates ever higher positive interest rates as we get closer to the edge of the market\n            // which also constitutes the underCollateralization event edge.\n            // @dev - sqrtPrices have a max of uint104, so _squareUnsafe will not overflow.\n            // @dev - WORKOUT_LN_RATE is negative\n            vars.spotLnRateBias =\n                int256(marketState.lexState.lastLnRateBias) -\n                int256(\n                    (marketState.lexState.lastSqrtPriceX96 <= lexParams.limMaxSqrtPriceX96)\n                        ? 0\n                        : Math.mulDiv(\n                            uint256(lexParams.debtDuration) * NEG_WORKOUT_LN_RATE,\n                            _squareUnsafe(marketState.lexState.lastSqrtPriceX96 - lexParams.limMaxSqrtPriceX96),\n                            _squareUnsafe(lexParams.edgeSqrtPriceX96_B - lexParams.limMaxSqrtPriceX96)\n                        )\n                );\n\n            // accrue interest (update cached debtNotionalPrice)\n            // @dev limits elapsedTime for the update to a full duration interval.\n            // @dev this limits interest accrual for inactive markets,\n            // but ensures interest accrual does not overshoot given accrueInterest approximations\n            // The maximum interest accrual below (in this update) is 1/price\n            // (e.g., if price is 0.95 in a 12 month duration market, and market gets updated in 24 months... the update is still only 5.2%)\n            vars.newDebtNotionalPrice = DebtMath.accrueInterest(\n                marketState.lexState.lastDebtNotionalPrice,\n                lexParams.debtDuration,\n                vars.spotPriceDiscount,\n                (vars.elapsedTime > lexParams.debtDuration) ? lexParams.debtDuration : vars.elapsedTime,\n                vars.spotLnRateBias\n            );\n\n            // accrue fees\n            // @dev - fee accruel linear instead of geometric to simplify math\n            // large timesteps lead to underaccrual of protocol fees\n            // @dev - do not accrue fees if LTV > MAX_LIMIT_LTV (high LTV or undercollateralized market)\n            if (\n                (marketState.lexConfig.protocolFee > 0) &&\n                (marketState.lexState.lastSqrtPriceX96 <= lexParams.limMaxSqrtPriceX96)\n            ) {\n                // split out fees\n                (vars.yieldFee, vars.tvlFee) = UtilsLib.decodeFee(marketState.lexConfig.protocolFee);\n\n                vars.feeX96 = 0;\n                if (vars.tvlFee > 0) {\n                    // @dev - increase resolution of calculation to X96 to account for small fees, baseTokenSupplies or elapsedTime\n                    vars.feeX96 = DebtMath.calculateLinearAccrual(\n                        baseTokenSupply,\n                        uint256(vars.tvlFee) << FixedPoint.RESOLUTION,\n                        vars.elapsedTime\n                    );\n                }\n                if ((vars.yieldFee > 0) && (vars.newDebtNotionalPrice > marketState.lexState.lastDebtNotionalPrice)) {\n                    // calculate estimate of yield accrued in base units\n                    // @dev - uses LTV instead of spot prices to lower gas cost\n                    // this uses the avg market price instead of spot price for conversion,\n                    // which leads to a higher yield estimation in low LTV environments vs high LTV environments\n                    // this behavior is acceptable given gas savings.\n                    vars.yieldInBaseUnits = marketState.baseTokenSupply.mulDiv(\n                        (vars.newDebtNotionalPrice - marketState.lexState.lastDebtNotionalPrice) *\n                            LatentMath.computeLTV(\n                                lexParams.edgeSqrtPriceX96_A,\n                                lexParams.edgeSqrtPriceX96_B,\n                                marketState.lexState.lastSqrtPriceX96\n                            ),\n                        marketState.lexState.lastDebtNotionalPrice * FixedPoint.PERCENTAGE_FACTOR\n                    );\n\n                    vars.feeX96 += vars.yieldInBaseUnits.mulDiv(\n                        uint256(vars.yieldFee) << FixedPoint.RESOLUTION,\n                        FixedPoint.PERCENTAGE_FACTOR\n                    );\n                }\n\n                vars.fee = vars.feeX96 / FixedPoint.Q96;\n\n                // Probabilistically (best effort) add +1 fee depending on remainder for small fees (FIX from Pashov Audit)\n                // @dev - this allows to probabilistically collect fees for low baseTokenSupplies, small fees, or small elapseTime\n                // @dev -  We use the probabilistic approach to lower gas cost (avoid an SSTORE),\n                // and only for fees < 100 given we are ok with a < 1% underaccrual of fees.\n                if (vars.fee < 100) {\n                    if (\n                        (vars.feeX96 % FixedPoint.Q96) >\n                        (uint256(\n                            keccak256(\n                                abi.encodePacked(\n                                    uint32(block.prevrandao),\n                                    uint32(block.timestamp),\n                                    uint128(marketState.baseTokenSupply),\n                                    uint64(marketState.lexState.lastSqrtPriceX96)\n                                )\n                            )\n                        ) >> 160)\n                    ) vars.fee += 1;\n                } else if (vars.fee > type(uint96).max) vars.fee = type(uint96).max;\n                if (vars.fee > (baseTokenSupply / 8)) vars.fee = baseTokenSupply / 8; // @dev set max update of 12.5% of baseTokenSupply\n\n                unchecked {\n                    marketState.accruedProtocolFee = uint96(vars.fee); //fits in uint96 given previous checks\n                    marketState.baseTokenSupply -= vars.fee; // @dev - remove fee from baseTokenSupply for all calculations going fwd\n                }\n            }\n            marketState.lexState.lastDebtNotionalPrice = vars.newDebtNotionalPrice;\n\n            /////////////////////////////////////\n            // Exponential TWAP\n            // @dev - stores an exponential moving avg of market baseSupply\n\n            // Calculate update factor with an approximate ETWAP_HALF_LIFE.\n            vars.invUpdateFactor = DebtMath.calculateApproxExponentialUpdate(\n                LN2,\n                vars.elapsedTime,\n                ETWAP_MIN_HALF_LIFE\n            );\n\n            marketState.lexState.lastETWAPBaseSupply =\n                marketState.lexState.lastETWAPBaseSupply.mulDiv(FixedPoint.RAY, vars.invUpdateFactor) +\n                marketState.baseTokenSupply.mulDiv(\n                    FixedPoint.RAY - (FixedPoint.RAY * FixedPoint.RAY) / vars.invUpdateFactor,\n                    FixedPoint.RAY\n                );\n        }\n\n        //////////////////////////////////////////////////////////////////////////////////////\n        // Calculate parameters for synth -> dex -> synth transforms (for BASE + DEBT only)\n        // @dev - these scaled amounts seek to ensure liquidity < 2^152.\n        // so, if liquidity is too big, I would make liquidityScaled ~ 2^152 = liquidity * X96 / divScaleFactorX96.\n        // so, divScaleFactorX96 = liquidity * X96 / 2^152 = liquidityRatioX96 * BaseTokenSupply / 2^152;\n        // @dev - saturates instead of reverting, meaning liquidity could still be > 2^152 even after applying this scaling.\n        // This would only happen in markets where the oracle price * baseTokenSupply itself overflows, and thus an unlikely scenario.\n        // if so, it will revert later when calculating liquidity.\n        // @dev - if baseTokenSupply < X96, then use X96.  We assume all viable markets can price (without overflow a minimum of X96 base tokens)\n        uint256 divScaleFactorX96 = marketState.liquidityRatioX96.saturatingMulShr(\n            marketState.baseTokenSupply.max(FixedPoint.Q96),\n            152\n        );\n        bool scaledLiquidity = divScaleFactorX96 > FixedPoint.Q96; // scaling only applies if divScaleFactorX96 > X96\n\n        // if divScaleFactorX96 < X96, then liquidity already < 2^152.  liquidity = liquidityRatioX96 * BaseTokenSupply / X96\n        // if divScaleFactorX96 > X96, then liquidityScaled = 2^152 = liquidityRatioX96 * BaseTokenSupply / divScaleFactorX96\n        marketState.dexAmountsScaled[uint8(AssetType.BASE)] = marketState.liquidityRatioX96;\n        marketState.synthAmountsScaled[uint8(AssetType.BASE)] = Math.ternary(\n            scaledLiquidity,\n            divScaleFactorX96,\n            FixedPoint.Q96\n        );\n\n        // check that (notionalPrice * debtSupply * X96 / WAD / synthAmountScaled[Base]) does not overflow.\n        // we have to use the synthAmountScaled[Base] across all assets to make the market consistent.\n        // dex amount cannot be bigger than maxDebt * X96 / synthAmountScaled[Base] < notionalPrice * debtSupply * X96 / WAD / synthAmountScaled[Base]\n        // thus, if maxDebt / notionalPrice < debtSupply / WAD, then market is undercollateralized.\n        marketState.dexAmountsScaled[uint8(AssetType.DEBT)] = (scaledLiquidity &&\n            marketState.lexState.lastDebtNotionalPrice < FixedPoint.Q160)\n            ? (divScaleFactorX96 < FixedPoint.Q192)\n                ? marketState.lexState.lastDebtNotionalPrice * FixedPoint.Q96\n                : marketState.lexState.lastDebtNotionalPrice.mulDiv(FixedPoint.Q96, FixedPoint.WAD)\n            : marketState.lexState.lastDebtNotionalPrice;\n\n        marketState.synthAmountsScaled[uint8(AssetType.DEBT)] = scaledLiquidity\n            ? (marketState.lexState.lastDebtNotionalPrice < FixedPoint.Q160)\n                ? (divScaleFactorX96 < FixedPoint.Q192)\n                    ? FixedPoint.WAD * divScaleFactorX96\n                    : divScaleFactorX96\n                : FixedPoint.WAD.mulDiv(divScaleFactorX96, FixedPoint.Q96)\n            : FixedPoint.WAD;\n\n        ////////////////////////////////////////////////////////////////////////////////\n        // Calculate liquidity from baseTokenSupply\n        marketState.liquidity = _synthToDex(\n            marketState,\n            marketState.baseTokenSupply,\n            AssetType.BASE,\n            Math.Rounding.Floor\n        ).toUint160();\n\n        ////////////////////////////////////////////////////////////////////////////////\n        // calculate values if market has liquidity\n        if (marketState.liquidity > 0) {\n            // Calculate debt balanced value from zTokenSupply\n            marketState.dexAmounts[DEBT] = _synthToDex(\n                marketState,\n                marketState.supplyAmounts[DEBT],\n                AssetType.DEBT,\n                Math.Rounding.Floor\n            );\n\n            // Check max value for debt, given availablie liquidity in market.\n            vars.maxDebtValue = LatentMath.computeMaxDebt(\n                lexParams.edgeSqrtPriceX96_A,\n                lexParams.edgeSqrtPriceX96_B,\n                marketState.liquidity\n            );\n\n            // if true, then system is undercollateralized (ie, debt notional value is above liquidity value)\n            // if so, reduce debt value to be system liquidity value\n            if (marketState.dexAmounts[DEBT] > vars.maxDebtValue) {\n                marketState.lexState.lastSqrtPriceX96 = lexParams.edgeSqrtPriceX96_B;\n                marketState.dexAmounts[DEBT] = vars.maxDebtValue;\n                marketState.dexAmounts[LVRG] = 0;\n                marketState.underCollateralized = true;\n            } else {\n                // calculate market price and aDexAmount given liquidity and zDexAmount\n                // @dev - it could happen that marketState.dexAmounts[LVRG] == 0,\n                // even if Liquidity > 0 and marketState.dexAmounts[DEBT] < maxDebtValue.\n                (marketState.dexAmounts[LVRG], marketState.lexState.lastSqrtPriceX96) = LatentMath\n                    .getMarketStateFromLiquidityAndDebt(\n                        lexParams.edgeSqrtPriceX96_A,\n                        lexParams.edgeSqrtPriceX96_B,\n                        marketState.liquidity,\n                        marketState.dexAmounts[DEBT]\n                    );\n            }\n        } else {\n            // If liquidity == 0, go through following scenarios to set price depending on whether\n            // there is any debt or leverage tokens in the market, or whether it is a fully empty market.\n            // @dev - any dust aTokens that might be left in the market is valueless.\n            // @dev - any dust zTokens left might have some value (if baseTokenSupply > 0) but very small (under < 10-15 in quote tokens for most market setups)\n            // but this undercollateralized state would not be resolved via workout accrual and might block the market,\n            // so we consider them valueless as well.\n            // Thus, we set the market price to uint160(FixedPoint.Q96) - uninitialized.\n            marketState.dexAmounts[LVRG] = 0;\n            marketState.dexAmounts[DEBT] = 0;\n            marketState.lexState.lastSqrtPriceX96 = (marketState.supplyAmounts[LVRG] > 0 &&\n                marketState.supplyAmounts[DEBT] == 0)\n                ? lexParams.edgeSqrtPriceX96_A\n                : uint160(FixedPoint.Q96);\n        }\n\n        //////////////////////////////////////////////////////////////////////////////////////\n        // Calculate parameters for synth -> dex -> synth transforms (for LVRG only)\n        // if no supply for leverage token, assume ratio == 1\n        // if dexAmounts[LVRG] = 0 while supplyAmounts[LVRG] > 0, we will set dexAmountScaled[LVRG] = 1\n        //  To ensure _synthToDex and _DexToSynth ratios work (and allow for LTV and cap checks)\n        // This might happen when liquidity > 0 but very close to being undercollateralized (without triggering the flag),\n        // or in markets where liquidity = 0 with leftover dust.\n        marketState.dexAmountsScaled[uint8(AssetType.LEVERAGE)] = Math.ternary(\n            marketState.supplyAmounts[LVRG] > 0,\n            Math.max(marketState.dexAmounts[LVRG], 1),\n            1\n        );\n        marketState.synthAmountsScaled[uint8(AssetType.LEVERAGE)] = Math.ternary(\n            marketState.supplyAmounts[LVRG] > 0,\n            marketState.supplyAmounts[LVRG],\n            1\n        );\n\n        return marketState;\n    }\n\n    // @dev - returns price discount in WADs\n    // ie. currentNotionalPrice = WAD indicates a price of 1 (ie, debt is trading at par)\n    function _getDebtPriceDiscount(\n        uint160 edgeSqrtPriceX96_A,\n        uint160 edgeSqrtPriceX96_B,\n        uint160 currentSqrtPriceX96,\n        uint256 target_dXdL_X96\n    ) internal pure returns (uint256 currentPriceDiscount) {\n        // @dev - in undercollateralized case, will correctly price discount such that\n        // the interest rate corresponds to a market that is 100% debt and 0% leverage,\n        // ie, the max interest rate of the market\n        uint256 current_dXdL_X96 = LatentMath.get_XvsL(\n            currentSqrtPriceX96,\n            edgeSqrtPriceX96_A,\n            edgeSqrtPriceX96_B,\n            AssetType.DEBT\n        );\n\n        return FixedPoint.WAD.mulDiv(target_dXdL_X96, current_dXdL_X96);\n    }\n\n    // checks market LTV and reverts if beyond bounds\n    // @dev - perform after action that should be prohibited if LTVs are off limits\n    function _checkLTV(uint160 nextSqrtPriceX96, uint160 sqrtPriceLimitX96) internal pure {\n        if (nextSqrtPriceX96 > sqrtPriceLimitX96) revert LSErrors.E_LEX_ActionNotAllowedGivenLTVlimit();\n    }\n\n    // checks and reverts if in undercollateralized state\n    function _checkUnderCollateralized(LexFullState memory marketState) internal pure {\n        if (marketState.underCollateralized) revert LSErrors.E_LEX_ActionNotAllowedUnderCollateralized();\n    }\n\n    function _checkMintCap(\n        uint256 marketBaseTokenSupply,\n        uint256 eTWAPBaseTokenSupply,\n        uint256 mintAmount,\n        uint8 noCapLimit\n    ) internal pure {\n        // if marketBaseTokenSupply <= AMOUNT_NO_CAP, then we can mint upto 2^96.\n        // ie, for small markets we can mint up 2^96 in one go (we assume markets can price correctly this amount of base tokens)\n        // But for bigger markets, mintAmount <= marketBaseTokenSupply << (MAX_MINT_FACTOR_CAP - 1)\n        // and marketBaseTokenSupply + mintAmount <= eTWAPBaseTokenSupply << MAX_MINT_FACTOR_CAP\n        // For MaxMintFactorCap = 1, this means mintAmount <= marketBaseTokenSupply (ie, we can double the market size in one call)\n        // as long as marketBaseTokenSupply + mintAmount <= eTWAPBaseTokenSupply << MAX_MINT_FACTOR_CAP.\n        // in practice, a user can mint upto  and are approx. ~MAX_MINT_FACTOR_CAP/2 can be minted every 1hr\n        // (this is based on ETWAP_MIN_HALF_LIFE and MAX_REDEEM_FACTOR_CAP values)\n        unchecked {\n            if (marketBaseTokenSupply <= (1 << noCapLimit)) {\n                if ((mintAmount > FixedPoint.Q96) && (mintAmount > marketBaseTokenSupply)) {\n                    revert LSErrors.E_LEX_MintCapExceeded();\n                }\n            } else if (\n                (mintAmount > marketBaseTokenSupply) ||\n                ((type(uint256).max - mintAmount) < marketBaseTokenSupply) ||\n                ((eTWAPBaseTokenSupply < (type(uint256).max >> MAX_MINT_FACTOR_CAP)) &&\n                    ((marketBaseTokenSupply + mintAmount) > (eTWAPBaseTokenSupply << MAX_MINT_FACTOR_CAP)))\n            ) {\n                revert LSErrors.E_LEX_MintCapExceeded();\n            }\n        }\n    }\n\n    function _checkRedeemCap(\n        uint256 marketBaseTokenSupply,\n        uint256 eTWAPBaseTokenSupply,\n        uint256 redeemAmount,\n        uint8 noCapLimit\n    ) internal pure {\n        // OK to redeem any amount if marketBaseTokenSupply < 10^noCapLimit\n        // ie, for small markets there is no limit on how much can be redeemed.\n        // But for bigger markets, approx. ~MAX_REDEEM_FACTOR_CAP/2 can be redeemed every 1hr\n        // (this is based on ETWAP_MIN_HALF_LIFE and MAX_REDEEM_FACTOR_CAP values)\n        unchecked {\n            if (\n                (marketBaseTokenSupply > (1 << noCapLimit)) &&\n                (marketBaseTokenSupply > redeemAmount) &&\n                ((marketBaseTokenSupply - redeemAmount) <\n                    (eTWAPBaseTokenSupply - (eTWAPBaseTokenSupply >> MAX_REDEEM_FACTOR_CAP)))\n            ) revert LSErrors.E_LEX_RedeemCapExceeded();\n        }\n    }\n\n    function _checkSynthMintCap(uint256 synthSupplyAmount, uint256 mintAmount) internal pure {\n        // ensure we are not miniting more than MAX_SYNTH_MINT_CAP for zToken and aToken\n        // Block minting while still allowing market value to appreciate.\n        if ((mintAmount > MAX_SYNTH_MINT_CAP) || ((MAX_SYNTH_MINT_CAP - mintAmount) < synthSupplyAmount))\n            revert LSErrors.E_LEX_MarketSizeLimitExceeded();\n    }\n\n    // ------------------ Synth to Dex conversions ---------\n\n    function _synthToDex(\n        LexFullState memory marketState,\n        uint256 synthAmount,\n        AssetType assetType,\n        Math.Rounding rounding\n    ) internal pure returns (uint256 dexAmount) {\n        return\n            synthAmount.mulDiv(\n                marketState.dexAmountsScaled[uint8(assetType)],\n                marketState.synthAmountsScaled[uint8(assetType)],\n                rounding\n            );\n    }\n\n    function _dexToSynth(\n        LexFullState memory marketState,\n        uint256 dexAmount,\n        AssetType assetType,\n        Math.Rounding rounding\n    ) internal pure returns (uint256 synthAmount) {\n        // @dev - using saturatingMulDiv avoids overflows that are then captured downstream.\n        // Specifically:\n        // 1) in ExactIn cases with synth outputs (e.g., mint, swap base -> synth, swap synth -> synth),\n        // if we saturate the amount of synth output, this is expected to be caught in the _checkSynthMintCap\n        // check.\n        // 2) in the ExactIn synth -> base swap, this would not saturate given we don't control the baseTokens in existence.\n        // 3) in the ExactOut case with synth inputs (e.g. swap synth -> synth), it would seem saturating the amount of synth coming in\n        // might create an issue (given more synths would be expected to come in given the synths going out).  however , we sould\n        // recall we are saturating to the max synth tokens in existence 2^256-1, and thus we are removing all of one type of synth and\n        // making the market be 100% the other type of synth.  In this situation, the market is correct.  We are eitehr 100% equity\n        // LatentSwap DEX will correctly price the leverage token.  Or we are 100% debt (and the transaction will revert given LTV limits).\n        return\n            dexAmount.saturatingMulDiv(\n                marketState.synthAmountsScaled[uint8(assetType)],\n                marketState.dexAmountsScaled[uint8(assetType)],\n                rounding\n            );\n    }\n\n    // Retrieve baseToken price\n    // @dev - baseTokenPrice is the value of 10^18 baseTokens, in quoteTokens, irrespective of actual # of decimal precision the baseToken has\n    function _readBasePriceAndCalculateLiqRatio(\n        MarketParams calldata marketParams,\n        uint256 targetXvsL,\n        int8 scaleDecimals,\n        bool isPreview\n    ) internal view returns (uint256 price, uint256 liqRatioX96) {\n        // targetXvsL is also the liquidity concentration of the market, and used here when calculating the liquidityRatio\n        // scaleDecimals ensures that final 'value' is in synth decimals (and not quote decimals)\n        uint256 scaledLiquidityConcentrationX96 = (scaleDecimals > 0)\n            ? FixedPoint.Q192 / (targetXvsL * (10 ** uint8(scaleDecimals)))\n            : (FixedPoint.Q192 * (10 ** uint8(-scaleDecimals))) / targetXvsL;\n\n        // liqRatioX96 represents the ratio transforming base token amounts to a concentrated value denominated liquidity\n        // @dev - getQuote is such that it returns the # of quote tokens, given # of base tokens coming in (irrespective of actual decimal representation).\n        liqRatioX96 = (isPreview)\n            ? IPriceOracle(marketParams.curator).previewGetQuote(\n                scaledLiquidityConcentrationX96,\n                marketParams.baseToken,\n                marketParams.quoteToken\n            )\n            : liqRatioX96 = IPriceOracle(marketParams.curator).getQuote(\n            scaledLiquidityConcentrationX96,\n            marketParams.baseToken,\n            marketParams.quoteToken\n        );\n\n        if (liqRatioX96 < MIN_LIQRATIOX96) revert LSErrors.E_LEX_OraclePriceTooLowForMarket();\n\n        // calculate price\n        // @dev - price is the # of quote tokens given 10^18 base tokens ,\n        // irrespective of actual # of decimal precision that baseToken or quoteToken has\n        price = FixedPoint.WAD.mulDiv(liqRatioX96, scaledLiquidityConcentrationX96);\n    }\n\n    function _calculateTokenPrices(\n        LexParams memory lexParams,\n        LexFullState memory marketState\n    ) internal pure returns (TokenPrices memory tokenPrices) {\n        // @notice - all prices are # of quote tokens received for 10^18 of base, leverage, or debt tokens\n        //(irrespective of actual decimal precision of each token type).\n        tokenPrices.baseTokenPrice = marketState.lexState.lastBaseTokenPrice;\n\n        // if market is undercollateralized and has leverage tokens, then leverage value is zero.\n        // otherwise, calculate price of leverage token  given baseTokenPrice and leverage price in the Covenant market\n        tokenPrices.aTokenPrice = (marketState.underCollateralized && marketState.dexAmounts[LVRG] > 0)\n            ? 0\n            : tokenPrices.baseTokenPrice.mulDiv(\n                _calcRatio(lexParams, marketState, AssetType.LEVERAGE, AssetType.BASE),\n                FixedPoint.WAD\n            );\n\n        // if market is undercollateralized and has debt, all base value is owned by debt.\n        // otherwise, calculate price of debt token  given baseTokenPrice and debt price in the Covenant market\n        tokenPrices.zTokenPrice = (marketState.underCollateralized && marketState.dexAmounts[DEBT] > 0)\n            ? tokenPrices.baseTokenPrice.mulDiv(marketState.baseTokenSupply, marketState.supplyAmounts[DEBT])\n            : tokenPrices.baseTokenPrice.mulDiv(\n                _calcRatio(lexParams, marketState, AssetType.DEBT, AssetType.BASE),\n                FixedPoint.WAD\n            );\n    }\n\n    function _squareUnsafe(uint256 value) internal pure returns (uint256) {\n        unchecked {\n            return value * value;\n        }\n    }\n}\n"
        },
        "src/synths/SynthToken.sol": {
            "content": "pragma solidity ^0.8.30;\n\nimport {ISynthToken, IERC20, MarketId, AssetType} from \"../interfaces/ISynthToken.sol\";\nimport {ERC20} from \"@openzeppelin/token/ERC20/ERC20.sol\";\n\n/**\n * @title Synthetic asset\n * @author Covenant Labs\n * @dev ERC20, closely integrated with CovenantCore\n */\ncontract SynthToken is ERC20, ISynthToken {\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Errors\n    error E_Synth_OnlyLEXCoreCanCall();\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    modifier onlyLexCore() {\n        if (_lexCore != _msgSender()) revert E_Synth_OnlyLEXCoreCanCall();\n        _;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    // Immutables\n\n    address private immutable _covenantCore;\n    address private immutable _lexCore; // autharized lex for mint/burn actions\n    MarketId private immutable _marketId; // marketId associated with synth token\n    AssetType private immutable _synthType; // type of synth token\n    uint8 private immutable _decimals; // asset decimals\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    // Constructor\n    constructor(\n        address covenantCore_,\n        address lexCore_,\n        MarketId marketId_,\n        IERC20 baseAsset_,\n        AssetType synthType_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _covenantCore = covenantCore_;\n        _lexCore = lexCore_;\n        _marketId = marketId_;\n        _synthType = synthType_;\n        _decimals = decimals_;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    // ERC20 Overrides\n\n    function decimals() public view override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    // Public Getters (non ERC20)\n\n    function getCovenantCore() external view override returns (address) {\n        return _covenantCore;\n    }\n\n    function getMarketId() external view override returns (MarketId) {\n        return _marketId;\n    }\n\n    function getSynthType() external view override returns (AssetType) {\n        return _synthType;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    // Covenant Liquid only functions (non ERC20)\n\n    /**\n     * @dev Expose share mint functionality to Covenant Liquid\n     */\n    function lexMint(address account, uint256 value) external onlyLexCore {\n        _mint(account, value);\n    }\n\n    /**\n     * @dev Expose share redeem functionality to Covenant Liquid\n     */\n    function lexBurn(address account, uint256 value) external onlyLexCore {\n        _burn(account, value);\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
        },
        "src/interfaces/ICovenant.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"./ISynthToken.sol\";\nimport {ILiquidExchangeModel} from \"./ILiquidExchangeModel.sol\";\nimport {Events} from \"../libraries/Events.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\n\ntype MarketId is bytes20;\n\n// Parameters that uniquely defines a Covenant market\nstruct MarketParams {\n    address baseToken;\n    address quoteToken;\n    address curator; // address of the oracle router\n    address lex;\n}\n\nstruct SynthTokens {\n    address aToken;\n    address zToken;\n}\n\nstruct MarketState {\n    uint256 baseSupply; // total base tokens for market\n    uint128 protocolFeeGrowth; // cumulative fee accrued by protocol in base tokens (unclaimed)\n    address authorizedPauseAddress; // address authorized to pause market\n    uint8 statusFlag; // 0 = uninitialized, 1 = unlocked, 2 = locked, 3 = paused\n}\n\nstruct SwapParams {\n    MarketId marketId;\n    MarketParams marketParams;\n    AssetType assetIn;\n    AssetType assetOut;\n    address to;\n    uint256 amountSpecified;\n    uint256 amountLimit;\n    bool isExactIn;\n    bytes data;\n    uint256 msgValue;\n}\n\nstruct RedeemParams {\n    MarketId marketId;\n    MarketParams marketParams;\n    uint256 aTokenAmountIn;\n    uint256 zTokenAmountIn;\n    address to;\n    uint256 minAmountOut;\n    bytes data;\n    uint256 msgValue;\n}\n\nstruct MintParams {\n    MarketId marketId;\n    MarketParams marketParams;\n    uint256 baseAmountIn;\n    address to;\n    uint256 minATokenAmountOut;\n    uint256 minZTokenAmountOut;\n    bytes data;\n    uint256 msgValue;\n}\n\nstruct TokenPrices {\n    uint256 baseTokenPrice;\n    uint256 aTokenPrice;\n    uint256 zTokenPrice;\n}\n\nenum AssetType {\n    BASE, // index 0\n    DEBT, // index 1\n    LEVERAGE, // index 2\n    COUNT // used to get the count of asset types\n}\n\n/**\n * @title ICovenant\n * @author Covenant Labs\n * @notice Defines the the core interface of Covenant Liquid markets.\n **/\ninterface ICovenant {\n    /// @notice Covenant name getter\n    function name() external view returns (string memory);\n\n    /// @notice MarketParams getter\n    function getIdToMarketParams(MarketId marketId) external view returns (MarketParams memory);\n\n    /// @notice MarketState getter\n    function getMarketState(MarketId marketId) external view returns (MarketState memory);\n\n    /// @notice Whether the LEX is enabled.\n    function isLexEnabled(address lex) external view returns (bool);\n\n    /// @notice Whether the Curator (oracle router) is enabled.\n    function isCuratorEnabled(address curator) external view returns (bool);\n\n    /**\n     * @notice creates a new Covenant Liquid market\n     * @param marketParams market initialization parameters\n     **/\n    function createMarket(MarketParams calldata marketParams, bytes calldata initData) external returns (MarketId);\n\n    /**\n     * @notice mints aTokens and zTokens from base tokens.\n     * @param mintParams mint parameters, as detailed below:\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - baseAmountIn: the amount of base token to deposit (and against which to mint a and z tokens)\n     * - to: the receiver of aTokens and zTokens\n     * - minATokenAmountOut: minimum ATokens out\n     * - minZTokenAmountOut: minimum Ztokens out\n     * - data: additional data to send to LEX\n     * - msgValue: msgValue to send to LEX if needed\n     * @return aTokenAmountOut amount of aToken minted\n     * @return zTokenAmountOut amount of zToken minted\n     **/\n    function mint(\n        MintParams calldata mintParams\n    ) external payable returns (uint256 aTokenAmountOut, uint256 zTokenAmountOut);\n\n    /**\n     * @notice Redeems aTokenAmount and zTokenAmount for base token.\n     * @notice Treats amounts as exact input, and does not check for slippage\n     * @dev This function send to LEX msgValue, but does not check whether msg.Value == msgValue (this is done to enable multicalls)\n     * @dev This means that calling with msgValue > msg.Value will revert, and msgValue < msg.Value\n     * @dev will leave excess value in the Covenant contract (which can be used by subsequent function calls or users)\n     * @param redeemParams redeem parameters, as follows:\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - aTokenAmountIn: the aTokenAmount being redeemed / burned (exact in)\n     * - zTokenAmountIn: the zTokenAmount being redeemed / burned (exact in)\n     * - to: the receiver of base tokens\n     * - minAmountOut: the minimum amount of base token out (for slippage / MEV protection)\n     * - data: additional data to send to LEX\n     * - msgValue: msgValue to send to LEX if needed\n     * @return baseAmountOut actual base tokens redeemed\n     **/\n    function redeem(RedeemParams calldata redeemParams) external payable returns (uint256 baseAmountOut);\n\n    /**\n     * @notice Executes a swap between any of the base, aToken, or zToken assets\n     * @dev All parameters are given in raw token decimal encoding.\n     * @dev function returns error if assets being swapped are not part of the same market\n     * @dev swapping between aTokens / zTokens actually mints / burns tokens\n     * @dev This function send to LEX msgValue, but does not check whether msg.Value == msgValue (this is done to enable multicalls)\n     * @dev This means that calling with msgValue > msg.Value will revert, and msgValue < msg.Value\n     * @dev will leave excess value in the Covenant contract (which can be used by subsequent function calls or users)\n     * @param swapParams swap parameters\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - assetIn: AssetType in\n     * - assetOut: AssetType out\n     * - to: the receiver of base tokens\n     * - amountSpecified: swap amount specified (amount in, if isExactIn == true)\n     * - amountLimit: swap reverts if less than amountLimit is return (if isExactIn), or more than amountLimit is expected as input (if !isExactIn)\n     * - isExactIn: whether swap is exact in, or exact out\n     * - data: additional data to send to LEX\n     * - msgValue: msgValue to send to LEX if needed\n     * @return amount amount of tokens swapped out / in, depending on whether swap isExactIn\n     **/\n    function swap(SwapParams calldata swapParams) external payable returns (uint256 amount);\n\n    /**\n     * @notice Updates market state (e.g., accrues debt fees and protocol fees)\n     * @dev Calling mint / redeem / swap also updates internal states, but updateState allows a user to update the state without mint / redeem /swapping tokens\n     * @dev This function send to LEX msgValue, but does not check whether msg.Value == msgValue (this is done to enable multicalls)\n     * @dev This means that calling with msgValue > msg.Value will revert, and msgValue < msg.Value\n     * @dev will leave excess value in the Covenant contract (which can be used by subsequent function calls or users)\n     * @param marketId market to update\n     * @param marketParams marketParams of market to update\n     * @param data additional data to send to LEX\n     * @param msgValue msgValue to send to LEX if needed\n     **/\n    function updateState(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        bytes calldata data,\n        uint256 msgValue\n    ) external payable;\n\n    /**\n     * @notice previews mint of aTokens and zTokens from base tokens, without changing market state\n     * @notice Treats amounts as exact input, runs validation logic as actual mint call\n     * @param mintParams mint parameters, as detailed below:\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - baseAmountIn: the amount of base token to deposit (and against which to mint a and z tokens)\n     * - to: the receiver of aTokens and zTokens\n     * - minATokenAmountOut: minimum ATokens out\n     * - minZTokenAmountOut: minimum Ztokens out\n     * @return aTokenAmountOut amount of aToken minted\n     * @return zTokenAmountOut amount of zToken minted\n     * @return protocolFees amount of fee charged by protocol in base tokens\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices returns the dex prices after the action\n     **/\n    function previewMint(\n        MintParams calldata mintParams\n    )\n        external\n        view\n        returns (\n            uint256 aTokenAmountOut,\n            uint256 zTokenAmountOut,\n            uint128 protocolFees,\n            uint128 oracleUpdateFee,\n            TokenPrices memory tokenPrices\n        );\n\n    /**\n     * @notice previews redeem of aTokenAmount and zTokenAmount for base token, without changing market state.\n     * @notice Treats amounts as exact input, runs validation logic as actual redeem call\n     * @param redeemParams redeem parameters, as follows:\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - aTokenAmountIn: the aTokenAmount being redeemed / burned (exact in)\n     * - zTokenAmountIn: the zTokenAmount being redeemed / burned (exact in)\n     * - to: the receiver of base tokens\n     * - minAmountOut: the minimum amount of base token out (for slippage / MEV protection)\n     * @return amountOut actual base tokens redeemed\n     * @return protocolFees amount of fee charged by protocol in base tokens\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices returns the dex prices after the action\n     **/\n    function previewRedeem(\n        RedeemParams calldata redeemParams\n    )\n        external\n        view\n        returns (uint256 amountOut, uint128 protocolFees, uint128 oracleUpdateFee, TokenPrices memory tokenPrices);\n\n    /**\n     * @notice Calculates output of a swap between any of the base, aToken, or zToken assets, without changing market\n     * @notice Runs validation logic as actual swap call\n     * @param swapParams swap parameters\n     * - marketId: the marketId\n     * - marketParams: the marketParams (can be derived from Id by caller using getIdToMarketParams)\n     * - assetIn: AssetType in\n     * - assetOut: AssetType out\n     * - to: the receiver of base tokens\n     * - amountSpecified: swap amount specified (amount in, if isExactIn == true)\n     * - amountLimit: swap reverts if less than amountLimit is return (if isExactIn), or more than amountLimit is expected as input (if !isExactIn)\n     * - isExactIn: whether swap is exact in, or exact out\n     * @return amountCalc amount of tokens swapped out / in, depending on whether swap is EXACT_IN / EXACT_OUT\n     * @return protocolFees amount of fee charged by protocol in base tokens\n     * @return oracleUpdateFee fees to pay as msgValue when calling mint() given mintParams.data package, if any\n     * @return tokenPrices returns the dex prices after the action\n     **/\n    function previewSwap(\n        SwapParams calldata swapParams\n    )\n        external\n        view\n        returns (uint256 amountCalc, uint128 protocolFees, uint128 oracleUpdateFee, TokenPrices memory tokenPrices);\n\n    /**\n     * @notice Payable multicall\n     * @notice Does not check msg.value received.  Instead, it uses any msgValues encoded in data and sends those onwards\n     * @notice This means that calling multicall where sum(data(msgValues)) > msg.Value will revert, and\n     * @notice sum(data(msgValues)) < msg.Value will leave excess value in the Covenant contract (which can be used by subsequent users)\n     * @param data array of call data\n     * @return results an array of return info\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /////////////////////////////////////////////////////////////////////////////////\n    // Restricted functions\n\n    /// @notice Set valid LEX contracts (onlyOwner)\n    /// @notice Disabling a LEX does not allow new markets with this LEX\n    /// but does not invalidate already created markets\n    function setEnabledLEX(address lex, bool isValid) external;\n\n    /// @notice Set valid Curator (oracle router) contracts (onlyOwner)\n    /// @notice Disabling a Curator does not allow new markets with this Curator\n    /// but does not invalidate already created markets\n    function setEnabledCurator(address curator, bool isValid) external;\n\n    /// @notice Set default protocol fee (onlyOwner)\n    function setDefaultFee(uint32 newFee) external;\n\n    /// @notice Set protocol fee for a market (onlyOwner)\n    function setMarketProtocolFee(\n        MarketId marketId,\n        MarketParams calldata marketParams,\n        bytes calldata data,\n        uint256 msgValue,\n        uint32 newFee\n    ) external payable;\n\n    /// @notice Collect protocol fees for a market (onlyOwner)\n    function collectProtocolFee(MarketId marketId, address recipient, uint128 amountRequested) external;\n\n    /// @notice Pause a market (only authorized pause address)\n    function setMarketPause(MarketId marketId, bool isPaused) external;\n\n    /// @notice Set default pause address (onlyOwner)\n    function setDefaultPauseAddress(address newPauseAddress) external;\n\n    /// @notice Set pause address for a market (onlyOwner)\n    function setMarketPauseAddress(MarketId marketId, address newPauseAddress) external;\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
        },
        "src/libraries/SafeMetadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@openzeppelin/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\n\nlibrary SafeMetadata {\n    /**\n     * @dev Attempts to fetch the asset name as a string. A return value of false indicates that the attempt failed in some way.\n     */\n    function tryGetName(IERC20 token) internal view returns (bool ok, string memory out) {\n        return _tryStringOrBytes32(address(token), IERC20Metadata.name.selector);\n    }\n\n    /**\n     * @dev Attempts to fetch the asset symbol as a string. A return value of false indicates that the attempt failed in some way.\n     */\n    function tryGetSymbol(IERC20 token) internal view returns (bool ok, string memory out) {\n        return _tryStringOrBytes32(address(token), IERC20Metadata.symbol.selector);\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function tryGetDecimals(IERC20 token) internal view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(token).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    function _tryStringOrBytes32(address token, bytes4 selector) private view returns (bool ok, string memory out) {\n        // Enforce read-only\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));\n        if (!success) return (false, \"\");\n\n        // Try standard (string).  Reverts on malformed data.\n        if (data.length >= 64) return (true, abi.decode(data, (string)));\n\n        // Fallback: bytes32 (older tokens)\n        if (data.length == 32) {\n            bytes32 raw = abi.decode(data, (bytes32));\n            return (true, _bytes32ToString(raw));\n        }\n\n        // Anything else: treat as failure\n        return (false, \"\");\n    }\n\n    // separate to allow try/catch\n    function _decodeString(bytes memory data) internal pure returns (string memory s) {\n        return abi.decode(data, (string));\n    }\n\n    function _bytes32ToString(bytes32 x) private pure returns (string memory) {\n        uint256 len = 32;\n        while (len > 0 && x[len - 1] == 0) {\n            unchecked {\n                len--;\n            }\n        }\n        bytes memory out = new bytes(len);\n        for (uint256 i = 0; i < len; ++i) out[i] = x[i];\n        return string(out);\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
        },
        "src/lex/latentswap/libraries/LatentMath.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {AssetType} from \"../../../interfaces/ILiquidExchangeModel.sol\";\nimport {Math} from \"@openzeppelin/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/utils/math/SafeCast.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\nimport {Uint512} from \"./Uint512.sol\";\n\n/**\n * @title Latent Math\n * @author Covenant Labs\n * @dev Library containing all the DEX functions for the exchange of liquidity vs leverage value and debt value.\n **/\n\nlibrary LatentMath {\n    using Math for uint256;\n    using SafeCast for uint256;\n    using SafeCast for bool;\n\n    struct ComputeLiquidityVars {\n        uint256 pDiffX96;\n        uint256 betaX96;\n        uint256 b2X192_0;\n        uint256 b2X192_1;\n        uint256 qX192_0;\n        uint256 qX192_1;\n        uint256 dX192_0;\n        uint256 dX192_1;\n    }\n\n    /**\n     * @notice Computes the liquidity invariant given the current balances.\n     * @dev - For covenant market limts (max 90% > LTV >= 50%, 1.6 > Pb/Pa > 1.004, price = 1 at target LTV),\n     * we find aTokenAmount and zTokenAmount should be < 2^152 to ensure no overflows and liquidity < 2^160.\n     * @param sqrtRatioX96_A low market price edge (price (token1/token0) when token0 = 0)\n     * @param sqrtRatioX96_B high market price edge ( price (token1/token0) when token1 = 0)\n     * @param zTokenAmount amount of zTokens in market\n     * @param aTokenAmount amount of aTokens in market\n     * @return liquidity The calculated liquidity of the pool\n     */\n    function computeLiquidity(\n        uint160 sqrtRatioX96_A,\n        uint160 sqrtRatioX96_B,\n        uint256 zTokenAmount,\n        uint256 aTokenAmount\n    ) internal pure returns (uint160) {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // L = invariant                               (L/PA - BX)(L.PB - BY) = L^2                  //\n        // PA = sqrt(price_0)                                                                        // \n        // PB = sqrt(price_1)                                                                        //\n        // BX = balance of coin X                                                                    //\n        // BY = balance of coin Y          `                                                         //\n        // @dev - reverts on overflow                                                                //\n        //                                                                                           //\n        // Computes L using square root solution                                                     //\n        //    L = beta + sqrt(beta^2 - q)                                                            //\n        // where                                                                                     //\n        //    beta = (Y + X*sqrt(p_a)*sqrt(p_b))/(2*(sqrt(p_b)-sqrt(p_a)))                           //\n        //    q = X*Y*sqrt(p_a)/(sqrt(p_b)-sqrt(p_a))                                                //\n        //                                                                                           //\n        //                                                                                           //\n        **********************************************************************************************/\n        ComputeLiquidityVars memory vars;\n        // @dev - For covenant market limts (max LTV = 90%, 1.6 > Pb/Pa > 1.004),\n        // we find that BaseTokenValue < Liquidity < 2^8 * BaseTokenValue.\n        // So BaseTokenValue < 2^152 to ensure Liquidity < 2^160 across markets.\n        // In addition, given market concavity, aTokenAmount < BaseTokenValue, and zTokenAmount < BaseTokenValue.\n        // At any point within the market limits.\n\n        // @dev - assumes sqrtPrice_B > sqrtPrice_A (otherwise reverts)\n        vars.pDiffX96 = (sqrtRatioX96_B - sqrtRatioX96_A);\n\n        // beta with X96 precision\n        // b = (Y + X*sqrt(p_a)*sqrt(p_b))/(2*(sqrt(p_b)-sqrt(p_a)))\n        // @dev - For covenant market limts (max LTV = 90%, Pb/Pa < 1.004),\n        // we have 1/(2*(sqrt(p_b)-sqrt(p_a))) < 2^8\n        // For markets with LTV > 50%, we also have sqrtRatioX96_A * sqrtRatioX96_B <= FixedPoint.Q192\n        // so, combined, FixedPoint.Q192 / (2 * vars.pDiffX96) < 2^8 * FixedPoint.Q96 < 2^102\n        // Thus, aTokenAmount and zTokenAmount < 2^154 for betaX96 to fit in uint256.\n        // (but should be further constrained to < 2^152 given previous comments)\n        vars.betaX96 =\n            Math.mulDiv(aTokenAmount, FixedPoint.Q192, vars.pDiffX96 << 1) +\n            Math.mulDiv(zTokenAmount * sqrtRatioX96_A, sqrtRatioX96_B, vars.pDiffX96 << 1);\n\n        // beta^2 with X192 precision (512)\n        (vars.b2X192_1, vars.b2X192_0) = Math.mul512(vars.betaX96, vars.betaX96);\n\n        // q = X*Y*sqrt(p_a)/(sqrt(p_b)-sqrt(p_a)), with X192 precision (512 bits)\n        // biggest aTokenAmount <= biggest zTokenAmount for markets with LTV >= 50%\n        // Liquidity =< aTokenAmount + zTokenAmount (== when currentPrice == 1 only).\n        // Given market constraints, sqrtA / (sqrtB - sqrtA) < 2^8.  Thus, aTokenAmount < 2^152 so as to not overflow.\n        // zTokenAmount can be < 2^160 in calculation below.\n        (vars.qX192_1, vars.qX192_0) = Math.mul512(\n            Math.mulDiv(\n                aTokenAmount,\n                uint256(sqrtRatioX96_A) << FixedPoint.RESOLUTION,\n                vars.pDiffX96,\n                Math.Rounding.Ceil\n            ),\n            zTokenAmount * FixedPoint.Q96\n        );\n\n        // add (beta^2 - q) if it is > 0. otherwise disrgard this term. (this could happen due to rounding for lower balances)\n        // check beta^2 > q for 512 bit numbers.\n        if ((vars.qX192_1 == vars.b2X192_1 || vars.qX192_0 < vars.b2X192_0) || vars.qX192_1 < vars.b2X192_1) {\n            // calculate difference.\n            (vars.dX192_0, vars.dX192_1) = Uint512.sub512x512(vars.b2X192_0, vars.b2X192_1, vars.qX192_0, vars.qX192_1);\n            // add sqrt of difference\n            vars.betaX96 += Uint512.sqrt512(vars.dX192_0, vars.dX192_1);\n        }\n\n        // @dev Return does not require toUint160() SafeCast given FixedPoint.RESOLUTION shiftRight.\n        return uint160(vars.betaX96 >> FixedPoint.RESOLUTION);\n    }\n\n    /**\n     * @notice Computes the required swap amounts\n     * @dev Does not verify price limits\n     * @dev - For large liquidity amounts, and low tokenIn amounts, the output will be zero\n     * @dev - Reverts for currentLiquidity == 0, currentSqrtRatioX96 == 0\n     * @param currentLiquidity The current liquidity\n     * @param currentSqrtRatioX96 The current market price\n     * @param tokenSpecified The index of the token that is specified for the swap\n     * @param amountSpecified The exact amount specified for the swap\n     * @param isExactIn Whether the amounts specified are for the token coming into the swap or not.\n     * @return amountCalculated The calculated amount (amountOut if isExactIn, or amountIn if !IsExactIn)\n     * @return nextSqrtRatioX96 The next market price after swap\n     */\n    function computeSwap(\n        uint160 currentLiquidity,\n        uint160 currentSqrtRatioX96,\n        AssetType tokenSpecified,\n        uint256 amountSpecified,\n        bool isExactIn\n    ) internal pure returns (uint256 amountCalculated, uint160 nextSqrtRatioX96) {\n        // In latent swaps, when an amount is coming in, it 'decreases' the balance of that token\n        // The amount out comes from an 'increase' in balance\n        if (tokenSpecified == AssetType.DEBT) {\n            // For exactIn, round to make sure we do not pass the target price. Given price is going down, round up.\n            // For !exactIn, round to make sure we pass the target price. Given price is going up, round up.\n            nextSqrtRatioX96 = SqrtPriceMath.getNextSqrtPriceFromAmount0(\n                currentSqrtRatioX96,\n                currentLiquidity,\n                amountSpecified,\n                isExactIn,\n                Math.Rounding.Ceil\n            );\n\n            // round down is exactIn, up otherwise\n            amountCalculated = SqrtPriceMath.getAmount1Delta(\n                currentSqrtRatioX96,\n                nextSqrtRatioX96,\n                currentLiquidity,\n                isExactIn ? Math.Rounding.Floor : Math.Rounding.Ceil\n            );\n        } else if (tokenSpecified == AssetType.LEVERAGE) {\n            // For exactIn, round to make sure we do not pass the target price. Given price is going up, round down.\n            // For !exactIn, round to make sure we pass the target price. Given price is going down, round down.\n            nextSqrtRatioX96 = SqrtPriceMath.getNextSqrtPriceFromAmount1(\n                currentSqrtRatioX96,\n                currentLiquidity,\n                amountSpecified,\n                isExactIn,\n                Math.Rounding.Floor\n            );\n\n            // round down is exactIn, up otherwise\n            amountCalculated = SqrtPriceMath.getAmount0Delta(\n                currentSqrtRatioX96,\n                nextSqrtRatioX96,\n                currentLiquidity,\n                isExactIn ? Math.Rounding.Floor : Math.Rounding.Ceil\n            );\n        } else revert();\n    }\n\n    /**\n     * @notice Calculate amount of a + z Tokens minted when a fixed amount of liquidity is added\n     * @dev Does not change current market price\n     * @dev Round calculated balance down.\n     * @param currentSqrtRatioX96 current market price\n     * @param  edgeSqrtRatioX96_A low market price edge\n     * @param  edgeSqrtRatioX96_B high market price edge\n     * @param liquidityIn Liquidity being added to the market\n     * @return zTokenAmount zTokenAmount minted\n     * @return aTokenAmount aTokenAmount minted\n     **/\n    function computeMint(\n        uint160 currentSqrtRatioX96,\n        uint160 edgeSqrtRatioX96_A,\n        uint160 edgeSqrtRatioX96_B,\n        uint160 liquidityIn\n    ) internal pure returns (uint256 zTokenAmount, uint256 aTokenAmount) {\n        zTokenAmount = SqrtPriceMath.getAmount0Delta(\n            currentSqrtRatioX96,\n            edgeSqrtRatioX96_A,\n            liquidityIn,\n            Math.Rounding.Floor\n        );\n        aTokenAmount = SqrtPriceMath.getAmount1Delta(\n            edgeSqrtRatioX96_B,\n            currentSqrtRatioX96,\n            liquidityIn,\n            Math.Rounding.Floor\n        );\n    }\n\n    /**\n     * @notice Computes liquidity out given exact zToken and aToken amounts\n     * @dev - Estimates liquidity out, with higher error the bigger % of liquidity being redeemed given market size\n     * @dev - Keeps nextSqrtRatioX96 within bounds\n     * @param currentLiquidity The current liquidity\n     * @param currentSqrtRatioX96 The current market price\n     * @param edgeSqrtRatioX96_A low market price edge\n     * @param edgeSqrtRatioX96_B high market price edge\n     * @param zTokenAmtIn The exact amount of zToken specified for the redeem\n     * @param zTokenAmtIn The exact amount of zToken specified for the redeem\n     * @return liquidityOut The liquidity amount calculated for redeem\n     * @return nextSqrtRatioX96 The next market price after swap\n     */\n    function computeRedeem(\n        uint160 currentLiquidity,\n        uint160 currentSqrtRatioX96,\n        uint160 edgeSqrtRatioX96_A,\n        uint160 edgeSqrtRatioX96_B,\n        uint256 zTokenAmtIn,\n        uint256 aTokenAmtIn\n    ) internal pure returns (uint160 liquidityOut, uint160 nextSqrtRatioX96) {\n        // Calculate current market dex amounts\n        // @dev - given getMarketStateFromLiquidityAndDebt(),\n        // calculated aDexAmount == actual aDexAmount in circulation\n        // calculated zDexAmount <= actual zDexAmount in circulation\n        // (given current market price)\n\n        (uint256 zDexAmount, uint256 aDexAmount) = computeMint(\n            currentSqrtRatioX96,\n            edgeSqrtRatioX96_A,\n            edgeSqrtRatioX96_B,\n            currentLiquidity\n        );\n\n        if (zTokenAmtIn >= zDexAmount && aTokenAmtIn >= aDexAmount) {\n            //Full burn\n            return (currentLiquidity, currentSqrtRatioX96);\n        } else {\n            // Calculate remaining zToken and aToken amounts after redeem (add 1 to overestimate)\n            uint256 remZamt = (zTokenAmtIn < zDexAmount) ? zDexAmount - zTokenAmtIn + 1 : 0;\n            uint256 remAamt = (aTokenAmtIn < aDexAmount) ? aDexAmount - aTokenAmtIn + 1 : 0;\n\n            // Calculate remaining liquidity (add 1 to force rounding up)\n            uint256 remLiq = (uint256(computeLiquidity(edgeSqrtRatioX96_A, edgeSqrtRatioX96_B, remZamt, remAamt)) + 1);\n\n            // set max remLiq as currentLiquidity (no need to safeCast remLiq after this)\n            if (remLiq > uint256(currentLiquidity)) remLiq = currentLiquidity;\n            liquidityOut = currentLiquidity - uint160(remLiq);\n            nextSqrtRatioX96 = (liquidityOut == 0)\n                ? currentSqrtRatioX96\n                : SqrtPriceMath.getNextSqrtPriceFromAmount0(\n                    edgeSqrtRatioX96_A,\n                    uint160(remLiq),\n                    remZamt,\n                    false,\n                    Math.Rounding.Ceil\n                );\n            if (nextSqrtRatioX96 > edgeSqrtRatioX96_B) nextSqrtRatioX96 = edgeSqrtRatioX96_B;\n            return (liquidityOut, nextSqrtRatioX96);\n        }\n    }\n\n    /**\n     * @notice Calculate the derivative of liquidity vs a given token (at tokenType), given all current balances.\n     * @param currentSqrtRatioX96 The current sqrtRatio of the market\n     * @param  edgeSqrtRatioX96_A low market price edge (price (token1/token0) when token0 = 0)\n     * @param  edgeSqrtRatioX96_B high market price edge ( price (token1/token0) when token1 = 0)\n     * @param tokenType the token balance we are calculating\n     * @return ratioX96 The derivative (spot price) of token vs liquidity, with X96 precision\n     * @dev the inverse derivatives are as follows\n     * dX/dL = 1/sqrt(Pa) - 2/sqrt(P) + sqrt(Pb)/P\n     * dY/dL = sqrt(Pb) - 2sqrt(P)+ P/sqrt(Pa)\n     * where Pa and Pb are the edge prices, and P is the current market spot price.\n     */\n    function get_XvsL(\n        uint160 currentSqrtRatioX96,\n        uint160 edgeSqrtRatioX96_A,\n        uint160 edgeSqrtRatioX96_B,\n        AssetType tokenType\n    ) internal pure returns (uint256 ratioX96) {\n        if (tokenType == AssetType.DEBT) {\n            // calculates inverse derivative with Q96 resolution\n            ratioX96 =\n                Math.mulDiv(edgeSqrtRatioX96_B, FixedPoint.Q192, currentSqrtRatioX96) /\n                currentSqrtRatioX96 +\n                FixedPoint.Q192 /\n                uint256(edgeSqrtRatioX96_A) -\n                (FixedPoint.Q192 << 1) /\n                currentSqrtRatioX96;\n        } else if (tokenType == AssetType.LEVERAGE) {\n            ratioX96 =\n                Math.mulDiv(currentSqrtRatioX96, currentSqrtRatioX96, edgeSqrtRatioX96_A) +\n                uint256(edgeSqrtRatioX96_B) -\n                (uint256(currentSqrtRatioX96) << 1);\n        } else revert();\n    }\n\n    /**\n     * @notice Functionality used in LatentSwapLEX to calculate aDexAmount + marketSqrt price given zDexAmount + market Liquidity\n     * @dev - functionality isolated into this function for testing purposes, to ensure updateMarket + redeem functionality are aligned\n     * @param edgeSqrtRatioX96_A low market price edge\n     * @param edgeSqrtRatioX96_B high market price edge\n     * @param liquidity The current market liquidity\n     * @param zDexAmount The exact amount of zToken specified for the redeem\n     * @return aDexAmount The derived aDexAmount\n     * @return currentSqrtPriceX96 The derived marketSqrtPriceX96\n     */\n    function getMarketStateFromLiquidityAndDebt(\n        uint160 edgeSqrtRatioX96_A,\n        uint160 edgeSqrtRatioX96_B,\n        uint160 liquidity,\n        uint256 zDexAmount\n    ) internal pure returns (uint256 aDexAmount, uint160 currentSqrtPriceX96) {\n        // calculate market price given liquidity and zDexAmount\n        // Round up current price (implicitly rounds up debt value, rounds down aDexAmount in next calculation)\n        currentSqrtPriceX96 = SqrtPriceMath.getNextSqrtPriceFromAmount0(\n            edgeSqrtRatioX96_A,\n            liquidity,\n            zDexAmount,\n            false,\n            Math.Rounding.Ceil\n        );\n\n        // calculate aSynthAmount given current price and market liquidity\n        // Round down aDexAmount\n        aDexAmount = SqrtPriceMath.getAmount1Delta(\n            edgeSqrtRatioX96_B,\n            currentSqrtPriceX96,\n            liquidity,\n            Math.Rounding.Floor\n        );\n    }\n\n    /**\n     * @notice Calculates marginal value of L vs debt when market price == 1\n     * @param edgeSqrtRatioX96_A low market price edge\n     * @param edgeSqrtRatioX96_B high market price edge\n     * @return targetXvsL XvsL when market on target (price == 1), with X96 precision\n     */\n    function targetXvsL(uint160 edgeSqrtRatioX96_A, uint160 edgeSqrtRatioX96_B) internal pure returns (uint256) {\n        return get_XvsL(uint160(FixedPoint.Q96), edgeSqrtRatioX96_A, edgeSqrtRatioX96_B, AssetType.DEBT);\n    }\n\n    /**\n     * @notice Calculates LTV given current market price and market edges.\n     * @param edgeSqrtRatioX96_A low market price edge\n     * @param edgeSqrtRatioX96_B high market price edge\n     * @param currentSqrtRatioX96 current market price\n     * @return LTV where 10000 = 100%\n     */\n    function computeLTV(\n        uint160 edgeSqrtRatioX96_A,\n        uint160 edgeSqrtRatioX96_B,\n        uint160 currentSqrtRatioX96\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // At extremes, all X or all Y markets have equivalent value                                 //\n        // (equal to value of collateral)                                                            //\n        //                                                                                           //\n        // All X coin Amount0 = Pb - Pa / Pb / Pa                                                    //\n        // All Y coin Amount1 = Pb - Pa                                                              //\n        //                                                                                           //\n        // Where                                                                                     //\n        // Pa = sqrt(price_0)                                                                        //\n        // Pb = sqrt(price_1)                                                                        //\n        // Pc = sqrt(price_current)                                                                  //\n        //                                                                                           //\n        //                                                                                           //\n        // Thus, from a value perspective, if Vx = Amount0, then Vy = Amount1 * Pb * Pa              //\n        //                                                                                           //\n        // We define LTV = Vx / (Vy + Vx)                                                            //\n        //               = Amount0 / (Amount0 + Amount1 * Pb * Pa)                                   //\n        //                                                                                           //\n        // Solving this (using Amount0 = 1 / Pc - 1 / Pa, and Amount 1 = Pb - Pc (see SqrtPriceMath) //\n        //                                                                                           //\n        // LTV = (Pc - Pa).Pb / [(Pc - Pa).Pb + (Pb - Pc).Pc]                                        //\n        //                                                                                           //\n        //                                                                                           //\n        **********************************************************************************************/\n\n        // @dev - does not revert for\n        // edgeSqrtRatioX96_B <= (2^32) * FixedPoint.Q96\n        // and 0 < edgeSqrtRatioX96_A <= currentSqrtRatioX96 <= edgeSqrtRatioX96_B\n        // given edgeSqrtRatioX96_B ^ 2 <= 2^256\n        uint256 calc1 = uint256(edgeSqrtRatioX96_B) * uint256(currentSqrtRatioX96 - edgeSqrtRatioX96_A);\n        uint256 calc2 = uint256(currentSqrtRatioX96) * uint256(edgeSqrtRatioX96_B - currentSqrtRatioX96);\n\n        return Math.mulDiv(FixedPoint.PERCENTAGE_FACTOR, calc1, calc1 + calc2);\n    }\n\n    /**\n     * @notice Returns the maximum debt amount (in dex units) given liquidity and limit prices\n     * @param edgeSqrtRatioX96_A low market price edge\n     * @param edgeSqrtRatioX96_B high market price edge\n     * @param liquidity current market liquidity\n     * @return maxDebt The maximum debt amount\n     */\n    function computeMaxDebt(\n        uint160 edgeSqrtRatioX96_A,\n        uint160 edgeSqrtRatioX96_B,\n        uint160 liquidity\n    ) internal pure returns (uint256) {\n        return SqrtPriceMath.getAmount0Delta(edgeSqrtRatioX96_B, edgeSqrtRatioX96_A, liquidity, Math.Rounding.Floor);\n    }\n}\n"
        },
        "src/lex/latentswap/libraries/DebtMath.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {FixedPointMathLib} from \"@solady/utils/FixedPointMathLib.sol\";\nimport {Math} from \"@openzeppelin/utils/math/Math.sol\";\nimport {SaturatingMath} from \"./SaturatingMath.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\n\n/**\n * @title DebtMath library\n * @author Covenant Labs\n * @notice Provides approximations for Perpetual Debt calculations\n */\nlibrary DebtMath {\n    using SaturatingMath for uint256;\n    using FixedPointMathLib for int256;\n    using Math for uint256;\n\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @notice calculates interest update factor given perpetual debt duration, debt notional price and elapsed time.\n     * @param _amount amount on which interest is being applied\n     * @param _duration effective duration of the debt (in seconds)\n     * @param _discountPrice discount price (vs debt notional) in WADs\n     * @param _elapsedTime time over which to accrue interest (in seconds)\n     * @param _lnRateBias additional market rate bias (that is not determined by price), in WADs\n     * @return updatedAmount_  the updated amount given debt interest rate and elapsed time\n     **/\n    function accrueInterest(\n        uint256 _amount,\n        uint256 _duration,\n        uint256 _discountPrice,\n        uint256 _elapsedTime,\n        int256 _lnRateBias\n    ) internal pure returns (uint256 updatedAmount_) {\n        // Calculate rate = - ln(price) + lnRateBias\n        // and then updates amount.\n        return accrueInterestLnRate(_amount, _lnRateBias - int256(_discountPrice).lnWad(), _elapsedTime, _duration);\n    }\n\n    /**\n     * @notice updates amount given duration, lnRate and elapsed time.\n     * @dev interest accrual saturates.  ie, calculation will not revert,\n     * and instead updatedAmount will be >0 and <=type(uint256).max\n     * @param _amount amount to be update given duration, lnRate and elapsed time.\n     * @param _duration effective duration of the debt (in seconds)\n     * @param _lnRate lnRate in WADs (lnRate < 1 is a negative interest rate)\n     * @param _elapsedTime time over which to accrue interest (in seconds)\n     * @return updatedAmount_  the updated amount given debt interest rate and elapsed time\n     **/\n    function accrueInterestLnRate(\n        uint256 _amount,\n        int256 _lnRate,\n        uint256 _elapsedTime,\n        uint256 _duration\n    ) internal pure returns (uint256 updatedAmount_) {\n        uint256 updateFactor = calculateApproxExponentialUpdate(\n            uint256((_lnRate >= 0) ? _lnRate : -_lnRate),\n            _elapsedTime,\n            _duration\n        );\n\n        if (_lnRate >= 0) {\n            return _amount.saturatingMulDiv(updateFactor, FixedPoint.RAY);\n        } else {\n            // @dev - when lnRate < 0, we calculate exp(x), but then divide _amount by that updatefactor.\n            // given e(-x) = 1 / e(x). Amount is never allowed to get to 0 from interest accrual.\n            updatedAmount_ = _amount.mulDiv(FixedPoint.RAY, updateFactor);\n            if (updatedAmount_ == 0 && _amount > 0) updatedAmount_ = 1;\n        }\n    }\n\n    /**\n     * @notice Calculates approximation of exp(lnRate * timeDelta / duration) for small values of rate * timeDelta / duration\n     * @dev rate * timeDelta / duration is considered small, given timeDelta << duration, and rangebound rate\n     * @dev A taylor expansion is used to calculate exp(rate * timeDelta / duration), and output will alwas be <= to the exact calculation.\n     * @dev Below calculation does not overflow, even in extremes.  e.g, max lnRAte\n     * @dev below does not overflow for reasonable extremes.  E.g, duration of 1 year (in seconds), time elapsed of 10,000 years, lnRate = 7.9 RAYS (= 250000% daily rate)\n     * @param _lnRate logaritmic rate. -ln(price) in WADs\n     * @param _timeDelta time over which to accrue interest (in seconds)\n     * @param _duration effective duration of the debt (in seconds)\n     * @return updateMultiplier_ the update multiplier (in RAYs) with which to update an amount\n     **/\n    function calculateApproxExponentialUpdate(\n        uint256 _lnRate,\n        uint256 _timeDelta,\n        uint256 _duration\n    ) internal pure returns (uint256 updateMultiplier_) {\n        // @dev- for extreme cases (e.g., daily 10000% interest rate over 10000 years, with duration = 1 day),\n        // both _lnRate and _timeDelta are expected to be < uint96.max, and the below\n        // calculation not to revert.\n\n        // approximation for exp(lnRate * timeDelta / duration)\n        uint256 rate1 = (_lnRate * _timeDelta * FixedPoint.WAD_RAY_RATIO) / _duration;\n        uint256 rate2 = rate1.mulDiv(rate1, 2 * FixedPoint.RAY);\n        uint256 rate3 = rate2.mulDiv(rate1, 3 * FixedPoint.RAY);\n        return FixedPoint.RAY + rate1 + rate2 + rate3;\n    }\n\n    // returns linear update multiplier (ray units)\n    // assumes rate in BPS for a yearly duration\n    // @dev - output value saturates at type(uint256).max\n    function calculateLinearAccrual(\n        uint256 _value,\n        uint256 _rateBPS,\n        uint256 _timeDelta\n    ) internal pure returns (uint256 accrualValue_) {\n        // @dev - Even for extreme rate and timeDelta cases, _rate expected to be < type(uint160).max\n        // and _timeDelta < type(uint96).max.  Given this, below does not revert for any\n        // _value <= type(uint256).max.\n\n        return _value.saturatingMulDiv(_rateBPS * _timeDelta, SECONDS_PER_YEAR * FixedPoint.PERCENTAGE_FACTOR);\n    }\n}\n"
        },
        "src/libraries/Utils.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\n/// @title Utils Library\n/// @author Covenant Labs\n/// @notice Library to convert a market to its id.\nlibrary UtilsLib {\n    function encodeFee(uint16 yieldFee, uint16 tvlFee) internal pure returns (uint32 protocolFee) {\n        return ((uint32(yieldFee) << 16) | uint32(tvlFee));\n    }\n\n    function decodeFee(uint32 protocolFee) internal pure returns (uint16 yieldFee, uint16 tvlFee) {\n        yieldFee = uint16(protocolFee >> 16);\n        tvlFee = uint16(protocolFee & 0xFFFF);\n    }\n}\n"
        },
        "lib/aave-v3-core/contracts/protocol/libraries/math/PercentageMath.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary PercentageMath {\n  // Maximum percentage factor (100.00%)\n  uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n  // Half percentage factor (50.00%)\n  uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n  /**\n   * @notice Executes a percentage multiplication\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return result value percentmul percentage\n   */\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n    assembly {\n      if iszero(\n        or(\n          iszero(percentage),\n          iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)))\n        )\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\n    }\n  }\n\n  /**\n   * @notice Executes a percentage division\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return result value percentdiv percentage\n   */\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n    assembly {\n      if or(\n        iszero(percentage),\n        iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\n    }\n  }\n}\n"
        },
        "src/lex/latentswap/libraries/SaturatingMath.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {Math} from \"@openzeppelin/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/utils/math/SafeCast.sol\";\n\n/**\n * @title SaturatingMath library\n * @author Covenant Labs\n * @notice Provides a saturating mulDiv operation\n */\nlibrary SaturatingMath {\n    // Returns a saturating mulDiv operation\n    // @dev - does not overflow, but instead returns type(uint256).max if so.\n    function saturatingMulDiv(\n        uint256 _numerator1,\n        uint256 _numerator2,\n        uint256 _denominator\n    ) internal pure returns (uint256) {\n        (uint256 high, uint256 low) = Math.mul512(_numerator1, _numerator2);\n\n        // @dev - below follows the logic of Math.mulDiv, but saturates instead of reverting.\n        if (high >= _denominator) {\n            // returns type(uint256).max for all overflow and _denominator == 0 conditions\n            return type(uint256).max;\n        } else if (high == 0) {\n            // @dev - execute 256 bit division here directly.\n            // already checked for denominator == 0\n            unchecked {\n                return low / _denominator;\n            }\n        } else {\n            // @dev - would be more efficient to do a 512 division here,\n            // but OpenZeppelin does not have a separate (already audited) function.\n            // So below recomputes Math.mul512 internally, and then performs the division.\n            // Does not revert given checks above.\n            return Math.mulDiv(_numerator1, _numerator2, _denominator);\n        }\n    }\n\n    function saturatingMulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Math.Rounding rounding\n    ) internal pure returns (uint256 result) {\n        result = saturatingMulDiv(x, y, denominator);\n        return\n            result +\n            SafeCast.toUint(\n                Math.unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0 && result < type(uint256).max\n            );\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. saturates instead of reverting.\n     * @dev Code copies @openzeppelin/utils/math/Math.sol:mulShr, but saturates instead of reverting.\n     */\n    function saturatingMulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = Math.mul512(x, y);\n            if (high >= 1 << n) {\n                return type(uint256).max; // @dev - saturates instead of reverting for overflow.\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n"
        },
        "lib/solady/src/utils/FixedPointMathLib.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18)  135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s  6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0  p1_1 | z_0   z_1 |\n                    // Final:  |   0   p1_0 | p1_1  z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`. Alias for `saturatingSub`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x * y)`.\n    function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `x != 0 ? x : y`, without branching.\n    function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != bytes32(0) ? x : y`, without branching.\n    function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != address(0) ? x : y`, without branching.\n    function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/utils/math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "src/libraries/Events.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.30;\n\nimport {MarketId, MarketParams, SynthTokens, TokenPrices, AssetType} from \"../interfaces/ICovenant.sol\";\n\nlibrary Events {\n    /**\n     * @dev Emitted on market creation\n     * @param marketId the market ID\n     * @param marketParams the market params\n     * @param initData additional data passed to LEX during initialization\n     * @param lexData additional data returned by LEX during initialization (ABI encoded)\n     **/\n    event CreateMarket(\n        MarketId indexed marketId,\n        MarketParams marketParams,\n        SynthTokens synthTokens,\n        bytes initData,\n        bytes lexData\n    );\n\n    /**\n     * @dev Emitted on mint\n     * @notice Event incorporates minimal price information (from which all prices can be derived)\n     * @param marketId the market indicating the aTokens / zTokens to mint given baseToken (there could be more than one market for the same baseToken)\n     * @param baseAmountIn the amount of base token to deposit (and against which to mint a and z tokens)\n     * @param sender the supplier of base Tokens\n     * @param receiver the receiver of aTokens and zTokens\n     * @param aTokenAmountOut amount of aToken minted\n     * @param zTokenAmountOut amount of zToken minted\n     * @param tokenPrices Prices, in WADS, of baseToken, aToken and zToken after action (denominated in Quote tokens)\n     **/\n    event Mint(\n        MarketId indexed marketId,\n        uint256 baseAmountIn,\n        address indexed sender,\n        address indexed receiver,\n        uint256 aTokenAmountOut,\n        uint256 zTokenAmountOut,\n        uint128 protocolFees,\n        TokenPrices tokenPrices\n    );\n\n    /**\n     * @dev Emitted on redeem\n     * @param marketId the market for which the aTokens / zTokens will be redeemed for baseToken\n     * @param aTokenAmountIn the aTokenAmount being redeemed / burned (exact in)\n     * @param zTokenAmountIn the zTokenAmount being redeemed / burned (exact in)\n     * @param sender the supplier of a and z tokens\n     * @param receiver the receiver of base tokens\n     * @param amountOut amount of base tokens sent out to receiver\n     * @param tokenPrices Prices, in WADS, of baseToken, aToken and zToken after action (denominated in Quote tokens)\n     **/\n    event Redeem(\n        MarketId indexed marketId,\n        uint256 aTokenAmountIn,\n        uint256 zTokenAmountIn,\n        address indexed sender,\n        address indexed receiver,\n        uint256 amountOut,\n        uint128 protocolFees,\n        TokenPrices tokenPrices\n    );\n\n    /**\n     * @dev Emitted on swap\n     * @param marketId the market in which the swap is executed\n     * @param assetIn type of token swapped in\n     * @param assetOut type of token swapped out\n     * @param amountIn amount of tokenIn received and burned by market during swap\n     * @param amountOut amount of tokenOut minted and sent by market during swap\n     * @param sender the supplier of tokenIn\n     * @param receiver the receiver of tokenOut\n     * @param tokenPrices Prices, in WADS, of baseToken, aToken and zToken after action (denominated in Quote tokens)\n     **/\n    event Swap(\n        MarketId indexed marketId,\n        AssetType assetIn,\n        AssetType assetOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        address indexed sender,\n        address indexed receiver,\n        uint128 protocolFees,\n        TokenPrices tokenPrices\n    );\n\n    /**\n     * @dev Emitted on LEX update\n     * @param LEXImplementationAddress address of lex logic implementation\n     * @param isEnabled whether the address is a valid implementation for new markets\n     **/\n    event UpdateEnabledLEX(address indexed LEXImplementationAddress, bool isEnabled);\n\n    /**\n     * @dev Emitted on Oracle update\n     * @param oracle address of oracle\n     * @param isEnabled whether the address is a valid oracle for new markets\n     **/\n    event UpdateEnabledOracle(address indexed oracle, bool isEnabled);\n\n    /**\n     * @dev Emitted on update of default protocol fee\n     * @param oldDefaultFee old default fee\n     * @param newDefaultFee new default fee\n     **/\n    event UpdateDefaultProtocolFee(uint32 oldDefaultFee, uint32 newDefaultFee);\n\n    /**\n     * @dev Emitted on update of a market protocol fee\n     * @param marketId market being updated\n     * @param oldMarketFee old default fee\n     * @param newMarketFee new default fee\n     **/\n    event UpdateMarketProtocolFee(MarketId indexed marketId, uint32 oldMarketFee, uint32 newMarketFee);\n\n    /**\n     * @dev Emitted when protocol fees are collected\n     * @param marketId market from which fees are being collected\n     * @param recipient recipient of collected fees\n     * @param asset asset in which fees are denominated\n     * @param amount amount collected\n     **/\n    event CollectProtocolFee(MarketId indexed marketId, address recipient, address asset, uint128 amount);\n\n    /**\n     * @dev Emitted when protocol is paused or unpaused\n     * @param marketId market from which fees are being collected\n     * @param isPaused whether the market is paused\n     **/\n    event MarketPaused(MarketId indexed marketId, bool isPaused);\n\n    /**\n     * @dev Emitted when default pause address is updated\n     * @param oldDefaultPauseAddress old default pause address\n     * @param newDefaultPauseAddress new default pause address\n     **/\n    event UpdateDefaultPauseAddress(address oldDefaultPauseAddress, address newDefaultPauseAddress);\n\n    /**\n     * @dev Emitted when authorized pause address for a market is updated\n     * @param marketId market from which pause address is being updated\n     * @param oldPauseAddress old authorized pause address\n     * @param newPauseAddress new authorized pause address\n     **/\n    event UpdateMarketPauseAddress(MarketId indexed marketId, address oldPauseAddress, address newPauseAddress);\n}\n"
        },
        "src/libraries/Errors.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.30;\n\nlibrary Errors {\n    error E_ZeroAmount(); // 0xaf4935be\n    error E_ZeroAddress(); // 0x459f5f6e\n    error E_CrossedLimit(); // 0xb8775684\n    error E_InsufficientAmount(); // 0x9950c184\n    error E_IncorrectMarketAsset(); // 0x76ba676e\n    error E_EqualSwapAssets(); // 0x213a0fd0\n    error E_MarketLocked(); // 0x8a7ede1f\n    error E_MarketPaused(); // 0xed9c479e\n    error E_MarketNonExistent(); // 0xe2f65643\n    error E_LEXimplementationNotAuthorized(); // 0xb4ee3f59\n    error E_CuratorNotAuthorized(); // 0x808c99be\n    error E_MarketAlreadyExists(); // 0x601494a7\n    error E_IncorrectMarketParams(); // 0x7f6cd0c7\n    error E_Unauthorized(); // 0x08e2ce17\n    error E_IncorrectPayment(); // 0xa705df45\n    error E_ProtocolFeeTooHigh(); // 0xc886fec7\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Panic.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
        },
        "src/lex/latentswap/libraries/SqrtPriceMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport {Math} from \"@openzeppelin/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/utils/math/SafeCast.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of token0\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of token0\n    /// @param rounding Whether to round result up or down\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0(\n        uint160 sqrtPX96,\n        uint160 liquidity,\n        uint256 amount,\n        bool add,\n        Math.Rounding rounding\n    ) internal pure returns (uint160) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product;\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1)\n                        // always fits in 160 bits\n                        return uint160(Math.mulDiv(numerator1, sqrtPX96, denominator, rounding));\n                }\n            }\n            // denominator is checked for overflow\n            uint256 denominator2 = (numerator1 / sqrtPX96) + amount;\n            if (rounding == Math.Rounding.Ceil) return uint160(Math.ceilDiv(numerator1, denominator2));\n            else return uint160(numerator1 / denominator2);\n        } else {\n            unchecked {\n                uint256 product;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n                uint256 denominator = numerator1 - product;\n                return Math.mulDiv(numerator1, sqrtPX96, denominator, rounding).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of token1\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of token1\n    /// @param rounding Whether to round result up or down\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1(\n        uint160 sqrtPX96,\n        uint160 liquidity,\n        uint256 amount,\n        bool add,\n        Math.Rounding rounding\n    ) internal pure returns (uint160) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (\n                        (rounding == Math.Rounding.Ceil)\n                            ? Math.ceilDiv((amount << FixedPoint.RESOLUTION), liquidity)\n                            : (amount << FixedPoint.RESOLUTION) / liquidity\n                    )\n                    : Math.mulDiv(amount, FixedPoint.Q96, liquidity, rounding)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            Math.Rounding invRounding = Math.Rounding(1 - uint8(rounding));\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (invRounding == Math.Rounding.Ceil)\n                        ? Math.ceilDiv(amount << FixedPoint.RESOLUTION, liquidity)\n                        : ((amount << FixedPoint.RESOLUTION) / liquidity)\n                    : Math.mulDiv(amount, FixedPoint.Q96, liquidity, invRounding)\n            );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            unchecked {\n                return uint160(sqrtPX96 - quotient);\n            }\n        }\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param rounding Whether to round the amount up or down\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint160 liquidity,\n        Math.Rounding rounding\n    ) internal pure returns (uint256 amount0) {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint.RESOLUTION;\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n            require(sqrtRatioAX96 > 0);\n\n            uint256 numerator3 = Math.mulDiv(numerator1, numerator2, sqrtRatioBX96, rounding);\n            return\n                (rounding == Math.Rounding.Ceil) ? Math.ceilDiv(numerator3, sqrtRatioAX96) : numerator3 / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param rounding Whether to round the amount up, or down\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint160 liquidity,\n        Math.Rounding rounding\n    ) internal pure returns (uint256 amount1) {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n            return Math.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint.Q96, rounding);\n        }\n    }\n}\n"
        },
        "src/lex/latentswap/libraries/Uint512.sol": {
            "content": "// SPDX-License-Identifier: GPLv3\npragma solidity ^0.8.30;\n\nimport {Math} from \"@openzeppelin/utils/math/Math.sol\";\n\n// Code developed by https://github.com/SimonSuckut/Solidity_Uint512/\n\nlibrary Uint512 {\n    /// @notice Calculates the difference of two uint512 (a - b)\n    /// @dev Does not revert on underflow (ie, does not revert if b > a)\n    /// @param a0 A uint256 representing the lower bits of the minuend.\n    /// @param a1 A uint256 representing the higher bits of the minuend.\n    /// @param b0 A uint256 representing the lower bits of the subtrahend.\n    /// @param b1 A uint256 representing the higher bits of the subtrahend.\n    /// @return r0 The result as an uint512. r0 contains the lower bits.\n    /// @return r1 The higher bits of the result.\n    function sub512x512(uint256 a0, uint256 a1, uint256 b0, uint256 b1) public pure returns (uint256 r0, uint256 r1) {\n        assembly {\n            r0 := sub(a0, b0)\n            r1 := sub(sub(a1, b1), lt(a0, b0))\n        }\n    }\n\n    /// @notice Calculates the square root of a 512 bit unsigned integer, rounding down.\n    /// @dev Uses the Karatsuba Square Root method. See https://hal.inria.fr/inria-00072854/document for details.\n    /// @param a0 A uint256 representing the low bits of the input.\n    /// @param a1 A uint256 representing the high bits of the input.\n    /// @return s The square root as an uint256. Result has at most 256 bit.\n    function sqrt512(uint256 a0, uint256 a1) public pure returns (uint256 s) {\n        // A simple 256 bit square root is sufficient\n        if (a1 == 0) return Math.sqrt(a0);\n\n        // The used algorithm has the pre-condition a1 >= 2**254\n        uint256 shift;\n\n        assembly {\n            let digits := mul(lt(a1, 0x100000000000000000000000000000000), 128)\n            a1 := shl(digits, a1)\n            shift := add(shift, digits)\n\n            digits := mul(lt(a1, 0x1000000000000000000000000000000000000000000000000), 64)\n            a1 := shl(digits, a1)\n            shift := add(shift, digits)\n\n            digits := mul(lt(a1, 0x100000000000000000000000000000000000000000000000000000000), 32)\n            a1 := shl(digits, a1)\n            shift := add(shift, digits)\n\n            digits := mul(lt(a1, 0x1000000000000000000000000000000000000000000000000000000000000), 16)\n            a1 := shl(digits, a1)\n            shift := add(shift, digits)\n\n            digits := mul(lt(a1, 0x100000000000000000000000000000000000000000000000000000000000000), 8)\n            a1 := shl(digits, a1)\n            shift := add(shift, digits)\n\n            digits := mul(lt(a1, 0x1000000000000000000000000000000000000000000000000000000000000000), 4)\n            a1 := shl(digits, a1)\n            shift := add(shift, digits)\n\n            digits := mul(lt(a1, 0x4000000000000000000000000000000000000000000000000000000000000000), 2)\n            a1 := shl(digits, a1)\n            shift := add(shift, digits)\n\n            a1 := or(a1, shr(sub(256, shift), a0))\n            a0 := shl(shift, a0)\n        }\n\n        uint256 sp = Math.sqrt(a1);\n        uint256 rp = a1 - (sp * sp);\n\n        uint256 nom;\n        uint256 denom;\n        uint256 u;\n        uint256 q;\n\n        assembly {\n            nom := or(shl(128, rp), shr(128, a0))\n            denom := shl(1, sp)\n            q := div(nom, denom)\n            u := mod(nom, denom)\n\n            // The nominator can be bigger than 2**256. We know that rp < (sp+1) * (sp+1). As sp can be\n            // at most floor(sqrt(2**256 - 1)) we can conclude that the nominator has at most 513 bits\n            // set. An expensive 512x256 bit division can be avoided by treating the bit at position 513 manually\n            let carry := shr(128, rp)\n            let x := mul(carry, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            q := add(q, div(x, denom))\n            u := add(u, add(carry, mod(x, denom)))\n            q := add(q, div(u, denom))\n            u := mod(u, denom)\n        }\n\n        unchecked {\n            s = (sp << 128) + q;\n\n            uint256 rl = ((u << 128) | (a0 & 0xffffffffffffffffffffffffffffffff));\n            uint256 rr = q * q;\n\n            if ((q >> 128) > (u >> 128) || (((q >> 128) == (u >> 128)) && rl < rr)) {\n                s = s - 1;\n            }\n\n            return s >> (shift / 2);\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "@std/=lib/forge-std/src/",
            "@clones/=lib/clones-with-immutable-args/src/",
            "@chainlink/=lib/chainlink-brownie-contracts/",
            "@openzeppelin/=lib/openzeppelin-contracts/contracts/",
            "@solady/=lib/solady/src/",
            "@aave/=lib/aave-v3-core/contracts/protocol/",
            "@euler-price-oracle/=lib/euler-price-oracle/src/",
            "aave-v3-core/=lib/aave-v3-core/",
            "forge-std/=lib/forge-std/src/",
            "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
            "chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/contracts/src/v0.6/vendor/@arbitrum/nitro-contracts/src/",
            "clones-with-immutable-args/=lib/clones-with-immutable-args/src/",
            "ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/",
            "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
            "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
            "openzeppelin-contracts/=lib/openzeppelin-contracts/",
            "solady/=lib/solady/src/",
            "@pendle/core-v2/=lib/euler-price-oracle/lib/pendle-core-v2-public/contracts/",
            "@pyth/=lib/euler-price-oracle/lib/pyth-sdk-solidity/",
            "@redstone/evm-connector/=lib/euler-price-oracle/lib/redstone-oracles-monorepo/packages/evm-connector/contracts/",
            "@uniswap/v3-core/=lib/euler-price-oracle/lib/v3-core/",
            "@uniswap/v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/",
            "ethereum-vault-connector/=lib/euler-price-oracle/lib/ethereum-vault-connector/",
            "euler-price-oracle/=lib/euler-price-oracle/src/",
            "openzeppelin/=lib/euler-price-oracle/lib/openzeppelin-contracts/contracts/",
            "pendle-core-v2-public/=lib/euler-price-oracle/lib/pendle-core-v2-public/contracts/",
            "pyth-sdk-solidity/=lib/pyth-sdk-solidity/",
            "redstone-oracles-monorepo/=lib/euler-price-oracle/lib/",
            "v3-core/=lib/euler-price-oracle/lib/v3-core/contracts/",
            "v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/contracts/"
        ],
        "optimizer": {
            "enabled": true,
            "runs": 3750
        },
        "metadata": {
            "useLiteralContent": false,
            "bytecodeHash": "ipfs",
            "appendCBOR": true
        },
        "outputSelection": {
            "*": {
                "": ["ast"],
                "*": [
                    "abi",
                    "evm.bytecode.object",
                    "evm.bytecode.sourceMap",
                    "evm.bytecode.linkReferences",
                    "evm.deployedBytecode.object",
                    "evm.deployedBytecode.sourceMap",
                    "evm.deployedBytecode.linkReferences",
                    "evm.deployedBytecode.immutableReferences",
                    "evm.methodIdentifiers",
                    "ir",
                    "irOptimized",
                    "metadata",
                    "irOptimizedAst"
                ]
            }
        },
        "evmVersion": "cancun",
        "viaIR": false,
        "libraries": {}
    }
}
