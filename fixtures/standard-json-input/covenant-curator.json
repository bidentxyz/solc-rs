{
    "language": "Solidity",
    "sources": {
        "src/curators/CovenantCurator.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IERC4626} from \"forge-std/interfaces/IERC4626.sol\";\nimport {Ownable2Step, Ownable} from \"@openzeppelin/access/Ownable2Step.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\nimport {Errors} from \"./lib/Errors.sol\";\n\n/// @title CovenantCurator\n/// @author Covenant Labs\n/// @notice Covenant Curator V1.0 is, among other things, an oracle router\n/// @notice The contract enables the curator to decide on oracle and ERC4626 to authorize\n/// @notice This is a very close copy to the oracle router contract in the euler-price-oracle library, adapted for Covenant under GPL.\n/// but extends logic to include pricePreviews and priceUpdates/getUpdateFee for pull oracles\n/// @notice All functions return a value.  if bid/ask price not implemented, then getQuotes returns bid = ask = getQuote()\n/// @dev Integration Note: The router supports pricing via `convertToAssets` for trusted `resolvedVaults`.\n/// By ERC4626 spec `convert*` ignores liquidity restrictions, fees, slippage and per-user restrictions.\n/// Therefore the reported price may not be realizable through `redeem` or `withdraw`.\ncontract CovenantCurator is Ownable2Step, IPriceOracle {\n    /// @inheritdoc IPriceOracle\n    string public constant name = \"CovenantCurator V1.0\";\n    /// @notice The PriceOracle to call if this router is not configured for base/quote.\n    /// @dev If `address(0)` then there is no fallback.\n    address public fallbackOracle;\n    /// @notice ERC4626 vaults resolved using internal pricing (`convertToAssets`).\n    mapping(address vault => address asset) public resolvedVaults;\n    /// @notice PriceOracle configured per asset pair.\n    /// @dev The keys are lexicographically sorted (asset0 < asset1).\n    mapping(address asset0 => mapping(address asset1 => address oracle)) internal oracles;\n\n    /// @notice Configure a PriceOracle to resolve an asset pair.\n    /// @param asset0 The address first in lexicographic order.\n    /// @param asset1 The address second in lexicographic order.\n    /// @param oracle The address of the PriceOracle that resolves the pair.\n    /// @dev If `oracle` is `address(0)` then the configuration was removed.\n    /// The keys are lexicographically sorted (asset0 < asset1).\n    event ConfigSet(address indexed asset0, address indexed asset1, address indexed oracle);\n    /// @notice Set a PriceOracle as a fallback resolver.\n    /// @param fallbackOracle The address of the PriceOracle that is called when base/quote is not configured.\n    /// @dev If `fallbackOracle` is `address(0)` then there is no fallback resolver.\n    event FallbackOracleSet(address indexed fallbackOracle);\n    /// @notice Mark an ERC4626 vault to be resolved to its `asset` via its `convert*` methods.\n    /// @param vault The address of the ERC4626 vault.\n    /// @param asset The address of the vault's asset.\n    /// @dev If `asset` is `address(0)` then the configuration was removed.\n    event ResolvedVaultSet(address indexed vault, address indexed asset);\n\n    /// @notice Deploy CovenantRouter.\n    /// @param _governor The address of the governor.\n    constructor(address _governor) Ownable(_governor) {\n        if (_governor == address(0)) revert Errors.PriceOracle_InvalidConfiguration();\n    }\n\n    /// @notice Configure a PriceOracle to resolve base/quote and quote/base.\n    /// @param base The address of the base token.\n    /// @param quote The address of the quote token.\n    /// @param oracle The address of the PriceOracle to resolve the pair.\n    /// @dev Callable only by the governor.\n    function govSetConfig(address base, address quote, address oracle) external onlyOwner {\n        // This case is handled by `resolveOracle`.\n        if (base == quote) revert Errors.PriceOracle_InvalidConfiguration();\n        (address asset0, address asset1) = _sort(base, quote);\n        oracles[asset0][asset1] = oracle;\n        emit ConfigSet(asset0, asset1, oracle);\n    }\n\n    /// @notice Configure an ERC4626 vault to use internal pricing via `convert*` methods.\n    /// @param vault The address of the ERC4626 vault.\n    /// @param set True to configure the vault, false to clear the record.\n    /// @dev Callable only by the governor. Vault must implement ERC4626.\n    /// Note: Before configuring a vault verify that its `convertToAssets` is secure.\n    function govSetResolvedVault(address vault, bool set) external onlyOwner {\n        address asset = set ? IERC4626(vault).asset() : address(0);\n        resolvedVaults[vault] = asset;\n        emit ResolvedVaultSet(vault, asset);\n    }\n\n    /// @notice Set a PriceOracle as a fallback resolver.\n    /// @param _fallbackOracle The address of the PriceOracle that is called when base/quote is not configured.\n    /// @dev Callable only by the governor. `address(0)` removes the fallback.\n    function govSetFallbackOracle(address _fallbackOracle) external onlyOwner {\n        fallbackOracle = _fallbackOracle;\n        emit FallbackOracleSet(_fallbackOracle);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getQuote(uint256 inAmount, address base, address quote) external view returns (uint256) {\n        address oracle;\n        (inAmount, base, quote, oracle) = resolveOracle(inAmount, base, quote);\n        if (base == quote) return inAmount;\n        return IPriceOracle(oracle).getQuote(inAmount, base, quote);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getQuotes(uint256 inAmount, address base, address quote) external view returns (uint256, uint256) {\n        address oracle;\n        (inAmount, base, quote, oracle) = resolveOracle(inAmount, base, quote);\n        if (base == quote) return (inAmount, inAmount);\n        return IPriceOracle(oracle).getQuotes(inAmount, base, quote);\n    }\n\n    /// @notice Get the PriceOracle configured for base/quote.\n    /// @param base The address of the base token.\n    /// @param quote The address of the quote token.\n    /// @return The configured `PriceOracle` for the pair or `address(0)` if no oracle is configured.\n    function getConfiguredOracle(address base, address quote) public view returns (address) {\n        (address asset0, address asset1) = _sort(base, quote);\n        return oracles[asset0][asset1];\n    }\n\n    /// @notice Resolve the PriceOracle to call for a given base/quote pair.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @dev Implements the following resolution logic:\n    /// 1. Check the base case: `base == quote` and terminate if true.\n    /// 2. If a PriceOracle is configured for base/quote in the `oracles` mapping, return it.\n    /// 3. If `base` is configured as a resolved ERC4626 vault, call `convertToAssets(inAmount)`\n    /// and continue the recursion, substituting the ERC4626 `asset` for `base`.\n    /// 4. As a last resort, return the fallback oracle or revert if it is not set.\n    /// @return The resolved amount. This value may be different from the original `inAmount`\n    /// if the resolution path included an ERC4626 vault present in `resolvedVaults`.\n    /// @return The resolved base.\n    /// @return The resolved quote.\n    /// @return The resolved PriceOracle to call.\n    function resolveOracle(\n        uint256 inAmount,\n        address base,\n        address quote\n    )\n        public\n        view\n        returns (uint256, /* resolvedAmount */ address, /* base */ address, /* quote */ address /* oracle */)\n    {\n        // 1. Check the base case.\n        if (base == quote) return (inAmount, base, quote, address(0));\n        // 2. Check if there is a PriceOracle configured for base/quote.\n        address oracle = getConfiguredOracle(base, quote);\n        if (oracle != address(0)) return (inAmount, base, quote, oracle);\n        // 3. Recursively resolve `base`.\n        address baseAsset = resolvedVaults[base];\n        if (baseAsset != address(0)) {\n            inAmount = IERC4626(base).convertToAssets(inAmount);\n            return resolveOracle(inAmount, baseAsset, quote);\n        }\n        // 4. Return the fallback or revert if not configured.\n        oracle = fallbackOracle;\n        if (oracle == address(0)) revert Errors.PriceOracle_NotSupported(base, quote);\n        return (inAmount, base, quote, oracle);\n    }\n\n    /// @notice Lexicographically sort two addresses.\n    /// @param assetA One of the assets in the pair.\n    /// @param assetB The other asset in the pair.\n    /// @return The address first in lexicographic order.\n    /// @return The address second in lexicographic order.\n    function _sort(address assetA, address assetB) internal pure returns (address, address) {\n        return assetA < assetB ? (assetA, assetB) : (assetB, assetA);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    // Additional functions for Covenant\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IPriceOracle\n    function previewGetQuote(uint256 inAmount, address base, address quote) external view returns (uint256) {\n        address oracle;\n        (inAmount, base, quote, oracle) = resolveOracle(inAmount, base, quote);\n        if (base == quote) return inAmount;\n        return IPriceOracle(oracle).previewGetQuote(inAmount, base, quote);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function previewGetQuotes(uint256 inAmount, address base, address quote) external view returns (uint256, uint256) {\n        address oracle;\n        (inAmount, base, quote, oracle) = resolveOracle(inAmount, base, quote);\n        if (base == quote) return (inAmount, inAmount);\n        return IPriceOracle(oracle).previewGetQuotes(inAmount, base, quote);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function updatePriceFeeds(address base, address quote, bytes calldata updateData) external payable {\n        address oracle;\n        (, base, quote, oracle) = resolveOracle(0, base, quote);\n        if (base == quote) {\n            if (msg.value > 0) revert Errors.PriceOracle_IncorrectPayment();\n            return;\n        }\n        return IPriceOracle(oracle).updatePriceFeeds{value: msg.value}(base, quote, updateData);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getUpdateFee(address base, address quote, bytes calldata updateData) external view returns (uint128) {\n        address oracle;\n        (, base, quote, oracle) = resolveOracle(0, base, quote);\n        if (base == quote) return 0;\n        return IPriceOracle(oracle).getUpdateFee(base, quote, updateData);\n    }\n}\n"
        },
        "lib/forge-std/src/interfaces/IERC4626.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC20.sol\";\n\n/// @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-4626\ninterface IERC4626 is IERC20 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    /// @dev\n    /// - MUST be an ERC-20 token contract.\n    /// - MUST NOT revert.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Returns the total amount of the underlying asset that is “managed” by Vault.\n    /// @dev\n    /// - SHOULD include any compounding that occurs from yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n    /// “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n    /// “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n    /// through a deposit call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n    /// - MUST NOT revert.\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n    ///   in the same transaction.\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   deposit execution, and are accounted for during deposit.\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some mint limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n    /// - MUST NOT revert.\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n    ///   same transaction.\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n    ///   execution, and are accounted for during mint.\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n    /// Vault, through a withdraw call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n    ///   called\n    ///   in the same transaction.\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   withdraw execution, and are accounted for during withdraw.\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n    /// through a redeem call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n    ///   same transaction.\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   redeem execution, and are accounted for during redeem.\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
        },
        "src/interfaces/IPriceOracle.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\n/**\n * @title IPriceOracle\n * @author Covenant Labs\n * @notice Defines the the core interface for Covenant oracles.\n * @notice Extends the oracle interface of Euler Labs, https://github.com/euler-xyz/euler-price-oracle/\n    to include pricePreviews and priceUpdates/getUpdateFee for pull oracles\n * @notice All functions return a value.  if bid/ask price not implemented, then getQuotes returns bid = ask = getQuote()\n **/\n\ninterface IPriceOracle {\n    /// @notice Get the name of the oracle.\n    /// @return The name of the oracle.\n    function name() external view returns (string memory);\n\n    /// @notice One-sided price: How much quote token you would get for inAmount of base token, assuming no price spread.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @return outAmount The amount of `quote` that is equivalent to `inAmount` of `base`.\n    function getQuote(uint256 inAmount, address base, address quote) external view returns (uint256 outAmount);\n\n    /// @notice Two-sided price: How much quote token you would get/spend for selling/buying inAmount of base token.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @return bidOutAmount The amount of `quote` you would get for selling `inAmount` of `base`.\n    /// @return askOutAmount The amount of `quote` you would spend for buying `inAmount` of `base`.\n    function getQuotes(\n        uint256 inAmount,\n        address base,\n        address quote\n    ) external view returns (uint256 bidOutAmount, uint256 askOutAmount);\n\n    /// @notice priceUpdate for pulled pricing (e.g., Pyth, Redstone, Chainlink datastreams)\n    /// @notice allows pushing pricing to be verified on-chain. Function is payable to receive required payment.\n    /// @param base The token that is being priced (use here for routing purposes).\n    /// @param quote The token that is the unit of account (use here for routing purposes).\n    /// @param updateData Update data package (contains price and other info to be verified onchain)\n    function updatePriceFeeds(address base, address quote, bytes calldata updateData) external payable;\n\n    /// @notice Returns the required fee to update an oracle price.\n    /// @param base The token that is being priced (use here for routing purposes).\n    /// @param quote The token that is the unit of account (use here for routing purposes).\n    /// @param updateData Array of price update data.\n    /// @return updateFee The required fee in Wei.\n    function getUpdateFee(\n        address base,\n        address quote,\n        bytes calldata updateData\n    ) external view returns (uint128 updateFee);\n\n    /// @notice Preview of getQuote, with a longer lookback window to avoid quote blocking\n    /// @notice One-sided price: How much quote token you would get for inAmount of base token, assuming no price spread.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @return outAmount The amount of `quote` that is equivalent to `inAmount` of `base`.\n    function previewGetQuote(uint256 inAmount, address base, address quote) external view returns (uint256 outAmount);\n\n    /// @notice Preview of getQuotes, with a longer lookback window to avoid quote blocking\n    /// @notice Two-sided price: How much quote token you would get/spend for selling/buying inAmount of base token.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param base The token that is being priced.\n    /// @param quote The token that is the unit of account.\n    /// @return bidOutAmount The amount of `quote` you would get for selling `inAmount` of `base`.\n    /// @return askOutAmount The amount of `quote` you would spend for buying `inAmount` of `base`.\n    function previewGetQuotes(\n        uint256 inAmount,\n        address base,\n        address quote\n    ) external view returns (uint256 bidOutAmount, uint256 askOutAmount);\n}\n"
        },
        "src/curators/lib/Errors.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Errors\n/// @author Covenant Labs\n/// @notice Collects common errors in PriceOracles.\n/// @notice This is a very close copy to the Errors contract in the euler-price-oracle library, adapted for Covenant under GPL.\nlibrary Errors {\n    /// @notice The external feed returned an invalid answer.\n    error PriceOracle_InvalidAnswer();\n    /// @notice The configuration parameters for the PriceOracle are invalid.\n    error PriceOracle_InvalidConfiguration();\n    /// @notice The base/quote path is not supported.\n    /// @param base The address of the base asset.\n    /// @param quote The address of the quote asset.\n    error PriceOracle_NotSupported(address base, address quote);\n    /// @notice The quote cannot be completed due to overflow.\n    error PriceOracle_Overflow();\n    /// @notice The price is too stale.\n    /// @param staleness The time elapsed since the price was updated.\n    /// @param maxStaleness The maximum time elapsed since the last price update.\n    error PriceOracle_TooStale(uint256 staleness, uint256 maxStaleness);\n    /// @notice The method can only be called by the governor.\n    error Governance_CallerNotGovernor();\n    /// @notice There is an incorrect payment in the call.\n    error PriceOracle_IncorrectPayment();\n    /// @notice The update data is invalid.\n    error PriceOracle_InvalidUpdateData();\n    /// @notice The method is not implemented.\n    error PriceOracle_NotImplemented();\n}\n"
        },
        "lib/forge-std/src/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "@std/=lib/forge-std/src/",
            "@clones/=lib/clones-with-immutable-args/src/",
            "@chainlink/=lib/chainlink-brownie-contracts/",
            "@openzeppelin/=lib/openzeppelin-contracts/contracts/",
            "@solady/=lib/solady/src/",
            "@aave/=lib/aave-v3-core/contracts/protocol/",
            "@euler-price-oracle/=lib/euler-price-oracle/src/",
            "aave-v3-core/=lib/aave-v3-core/",
            "forge-std/=lib/forge-std/src/",
            "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
            "chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/contracts/src/v0.6/vendor/@arbitrum/nitro-contracts/src/",
            "clones-with-immutable-args/=lib/clones-with-immutable-args/src/",
            "ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/",
            "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
            "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
            "openzeppelin-contracts/=lib/openzeppelin-contracts/",
            "solady/=lib/solady/src/",
            "@pendle/core-v2/=lib/euler-price-oracle/lib/pendle-core-v2-public/contracts/",
            "@pyth/=lib/euler-price-oracle/lib/pyth-sdk-solidity/",
            "@redstone/evm-connector/=lib/euler-price-oracle/lib/redstone-oracles-monorepo/packages/evm-connector/contracts/",
            "@uniswap/v3-core/=lib/euler-price-oracle/lib/v3-core/",
            "@uniswap/v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/",
            "ethereum-vault-connector/=lib/euler-price-oracle/lib/ethereum-vault-connector/",
            "euler-price-oracle/=lib/euler-price-oracle/src/",
            "openzeppelin/=lib/euler-price-oracle/lib/openzeppelin-contracts/contracts/",
            "pendle-core-v2-public/=lib/euler-price-oracle/lib/pendle-core-v2-public/contracts/",
            "pyth-sdk-solidity/=lib/pyth-sdk-solidity/",
            "redstone-oracles-monorepo/=lib/euler-price-oracle/lib/",
            "v3-core/=lib/euler-price-oracle/lib/v3-core/contracts/",
            "v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/contracts/"
        ],
        "optimizer": {
            "enabled": true,
            "runs": 3750
        },
        "metadata": {
            "useLiteralContent": false,
            "bytecodeHash": "ipfs",
            "appendCBOR": true
        },
        "outputSelection": {
            "*": {
                "": ["ast"],
                "*": [
                    "abi",
                    "evm.bytecode.object",
                    "evm.bytecode.sourceMap",
                    "evm.bytecode.linkReferences",
                    "evm.deployedBytecode.object",
                    "evm.deployedBytecode.sourceMap",
                    "evm.deployedBytecode.linkReferences",
                    "evm.deployedBytecode.immutableReferences",
                    "evm.methodIdentifiers",
                    "ir",
                    "irOptimized",
                    "metadata",
                    "irOptimizedAst"
                ]
            }
        },
        "evmVersion": "cancun",
        "viaIR": false,
        "libraries": {}
    }
}
